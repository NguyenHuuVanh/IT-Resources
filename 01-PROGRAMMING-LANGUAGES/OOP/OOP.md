# OOP lÃ  gÃ¬? Chi tiáº¿t vá» láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng

## Má»¥c lá»¥c

1. [OOP lÃ  gÃ¬?](#1-oop-lÃ -gÃ¬)
2. [CÃ¡c thÃ nh pháº§n chÃ­nh trong OOP](#2-cÃ¡c-thÃ nh-pháº§n-chÃ­nh-trong-oop)
3. [4 tÃ­nh cháº¥t cÆ¡ báº£n trong OOP](#3-4-tÃ­nh-cháº¥t-cÆ¡-báº£n-trong-oop)
   - 3.1 [Encapsulation (TÃ­nh Ä‘Ã³ng gÃ³i)](#31-encapsulation-tÃ­nh-Ä‘Ã³ng-gÃ³i)
   - 3.2 [Abstraction (TÃ­nh trá»«u tÆ°á»£ng)](#32-abstraction-tÃ­nh-trá»«u-tÆ°á»£ng)
   - 3.3 [Inheritance (TÃ­nh káº¿ thá»«a)](#33-inheritance-tÃ­nh-káº¿-thá»«a)
   - 3.4 [Polymorphism (TÃ­nh Ä‘a hÃ¬nh)](#34-polymorphism-tÃ­nh-Ä‘a-hÃ¬nh)
   - 3.5 [VÃ­ dá»¥ 4 tÃ­nh cháº¥t báº±ng C++ vÃ  JavaScript](#35-vÃ­-dá»¥-4-tÃ­nh-cháº¥t-oop-báº±ng-c-vÃ -javascript)
4. [VÃ¬ sao nÃªn há»c OOP](#4-vÃ¬-sao-nÃªn-há»c-oop)
5. [CÃ¡c háº¡n cháº¿ cá»§a OOP](#5-cÃ¡c-háº¡n-cháº¿-cá»§a-láº­p-trÃ¬nh-hÆ°á»›ng-Ä‘á»‘i-tÆ°á»£ng-oop)
6. [Káº¿t luáº­n](#6-káº¿t-luáº­n)
7. [SOLID Principles](#7-solid-principles)
8. [Design Patterns phá»• biáº¿n](#8-design-patterns-phá»•-biáº¿n-trong-oop)

---

## Giá»›i thiá»‡u

ChÃºng ta Ä‘ang sá»­ dá»¥ng cÃ¡c ngÃ´n ngá»¯ láº­p trÃ¬nh Ä‘á»ƒ giáº£i quyáº¿t cÃ¡c váº¥n Ä‘á» trong cuá»™c sá»‘ng hÃ ng ngÃ y. VÃ¬ tháº¿ sáº½ khÃ´ng lÃ½ gÃ¬ chÃºng ta láº¡i khÃ´ng thá»ƒ mÃ´ hÃ¬nh cÃ¡c váº¥n Ä‘á» nÃ y sang cÃ¡c ngÃ´n ngá»¯ láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng. ÄÃ¢y chÃ­nh lÃ  nÆ¡i mÃ  láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng (**Object-oriented programming**) phÃ¡t huy vai trÃ² cá»§a nÃ³.

---

## 1. OOP lÃ  gÃ¬?

**OOP** lÃ  viáº¿t táº¯t cá»§a **Object-oriented programming** (láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng).

### Äá»‹nh nghÄ©a

OOP lÃ  viáº¿t táº¯t cá»§a Object-oriented programming (láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng). OOP lÃ  má»™t mÃ´ hÃ¬nh láº­p trÃ¬nh dá»±a trÃªn khÃ¡i niá»‡m vá» **Class** vÃ  **Object**. MÃ´ hÃ¬nh nÃ y táº­p trung vÃ o cÃ¡c Ä‘á»‘i tÆ°á»£ng tÆ°Æ¡ng tÃ¡c vá»›i nhau
thay vÃ¬ táº­p trung vÃ o logic Ä‘á»ƒ thao tÃ¡c chÃºng.

### Má»¥c tiÃªu chÃ­nh

- âœ… GiÃºp viá»‡c **quáº£n lÃ½ mÃ£ nguá»“n** dá»… dÃ ng hÆ¡n
- âœ… TÄƒng kháº£ nÄƒng **tÃ¡i sá»­ dá»¥ng code**
- âœ… **Báº£o trÃ¬** vÃ  **má»Ÿ rá»™ng** code Ä‘Æ¡n giáº£n hÆ¡n

### ThÃ nh pháº§n cá»§a Object

Trong OOP, má»™t Object thÆ°á»ng chá»©a 2 thÃ nh pháº§n:

1. **Data** (Dá»¯ liá»‡u)

   - DÆ°á»›i dáº¡ng cÃ¡c **fields** (trÆ°á»ng)
   - CÃ²n gá»i lÃ  **attributes** (thuá»™c tÃ­nh) hoáº·c **properties** (Ä‘áº·c tÃ­nh)

2. **Code** (MÃ£)
   - DÆ°á»›i dáº¡ng cÃ¡c **procedures** (thá»§ tá»¥c)
   - CÃ²n gá»i lÃ  **methods** (phÆ°Æ¡ng thá»©c)

---

## 2. CÃ¡c thÃ nh pháº§n chÃ­nh trong OOP

![CÃ¡c thÃ nh pháº§n trong OOP - Láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng](../../09-RESOURCES/images/image18.png)

Trong OOP cÃ³ 2 thÃ nh pháº§n chÃ­nh: **Class** vÃ  **Object**

### 2.1 Class (Lá»›p) trong OOP

**Class** lÃ  má»™t **template** (khuÃ´n máº«u) hay **blueprint** (báº£n thiáº¿t káº¿) Ä‘á»ƒ táº¡o ra cÃ¡c Object.

#### Class bao gá»“m:

- **Attributes**: Äá»‹nh nghÄ©a cÃ¡c thÃ´ng tin, Ä‘áº·c Ä‘iá»ƒm, thuá»™c tÃ­nh cá»§a Object
- **Methods**: Äá»‹nh nghÄ©a cÃ¡c hÃ nh vi, phÆ°Æ¡ng thá»©c, hÃ nh Ä‘á»™ng cá»§a Object

#### VÃ­ dá»¥ Class Person

```java
class Person {
    // Attributes (Thuá»™c tÃ­nh)
    String name;
    int age;
    String occupation;

    // Methods (PhÆ°Æ¡ng thá»©c)
    void eat() {
        System.out.println(name + " is eating");
    }

    void sleep() {
        System.out.println(name + " is sleeping");
    }

    void work() {
        System.out.println(name + " is working");
    }
}
```

### 2.2 Object (Äá»‘i tÆ°á»£ng) trong OOP

**Object** lÃ  má»™t **instance** (thá»ƒ hiá»‡n) cá»§a Class - má»™t vÃ­ dá»¥ cá»¥ thá»ƒ, hiá»‡n thá»±c cá»§a má»™t Class.

#### VÃ­ dá»¥ Objects tá»« Class Person

![VÃ­ dá»¥ Objects](../../09-RESOURCES/images/image17.png)

```java
// Táº¡o Objects tá»« Class Person
Person person1 = new Person();
person1.name = "Nguyá»…n VÄƒn A";
person1.age = 25;
person1.occupation = "Developer";

Person person2 = new Person();
person2.name = "Tráº§n Thá»‹ B";
person2.age = 30;
person2.occupation = "Designer";

// Sá»­ dá»¥ng methods
person1.eat();    // Output: Nguyá»…n VÄƒn A is eating
person2.work();   // Output: Tráº§n Thá»‹ B is working
```

**So sÃ¡nh Class vs Object:**

```
Class Person = Báº£n thiáº¿t káº¿ con ngÆ°á»i
  â†“
Object person1 = Nguyá»…n VÄƒn A (ngÆ°á»i cá»¥ thá»ƒ)
Object person2 = Tráº§n Thá»‹ B (ngÆ°á»i cá»¥ thá»ƒ)
```

---

## 3. 4 tÃ­nh cháº¥t cÆ¡ báº£n trong OOP

![4 tÃ­nh cháº¥t OOP](../../09-RESOURCES/images/image19.png)

OOP cÃ³ 4 tÃ­nh cháº¥t cÆ¡ báº£n (4 trá»¥ cá»™t) - thÆ°á»ng Ä‘Æ°á»£c gá»i lÃ  **4 Pillars of OOP**:

| #   | TÃ­nh cháº¥t         | Tiáº¿ng Viá»‡t      | Ã nghÄ©a cá»‘t lÃµi                                   |
| --- | ----------------- | --------------- | ------------------------------------------------- |
| 1   | **Encapsulation** | TÃ­nh Ä‘Ã³ng gÃ³i   | GÃ³i gá»n data vÃ  methods, kiá»ƒm soÃ¡t truy cáº­p       |
| 2   | **Abstraction**   | TÃ­nh trá»«u tÆ°á»£ng | áº¨n chi tiáº¿t phá»©c táº¡p, chá»‰ hiá»‡n interface Ä‘Æ¡n giáº£n |
| 3   | **Inheritance**   | TÃ­nh káº¿ thá»«a    | Class con thá»«a hÆ°á»Ÿng tá»« class cha                 |
| 4   | **Polymorphism**  | TÃ­nh Ä‘a hÃ¬nh    | Má»™t hÃ nh Ä‘á»™ng, nhiá»u cÃ¡ch thá»±c hiá»‡n               |

### Tá»•ng quan 4 tÃ­nh cháº¥t

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         4 PILLARS OF OOP                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚  ENCAPSULATION  â”‚    â”‚   ABSTRACTION   â”‚                            â”‚
â”‚  â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚    â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  "ÄÃ³ng há»™p"     â”‚    â”‚  "Giáº¥u phá»©c táº¡p"â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  â€¢ private data â”‚    â”‚  â€¢ abstract     â”‚                            â”‚
â”‚  â”‚  â€¢ getter/setterâ”‚    â”‚  â€¢ interface    â”‚                            â”‚
â”‚  â”‚  â€¢ validation   â”‚    â”‚  â€¢ hide details â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  Báº£o vá»‡ dá»¯ liá»‡u â”‚    â”‚  ÄÆ¡n giáº£n hÃ³a   â”‚                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚   INHERITANCE   â”‚    â”‚  POLYMORPHISM   â”‚                            â”‚
â”‚  â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚    â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  "Con giá»‘ng cha"â”‚    â”‚  "Nhiá»u hÃ¬nh"   â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  â€¢ extends      â”‚    â”‚  â€¢ overloading  â”‚                            â”‚
â”‚  â”‚  â€¢ super class  â”‚    â”‚  â€¢ overriding   â”‚                            â”‚
â”‚  â”‚  â€¢ reuse code   â”‚    â”‚  â€¢ flexibility  â”‚                            â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚                            â”‚
â”‚  â”‚  TÃ¡i sá»­ dá»¥ng    â”‚    â”‚  Linh hoáº¡t      â”‚                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Má»‘i quan há»‡ giá»¯a 4 tÃ­nh cháº¥t

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   ABSTRACTION   â”‚
                    â”‚ (Thiáº¿t káº¿ tá»•ng  â”‚
                    â”‚   quan, áº©n      â”‚
                    â”‚   complexity)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
              â–¼              â–¼              â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ENCAPSULATIONâ”‚  â”‚INHERITANCE â”‚  â”‚POLYMORPHISMâ”‚
     â”‚(Báº£o vá»‡ data)â”‚  â”‚(TÃ¡i sá»­ dá»¥ng)â”‚  â”‚(Linh hoáº¡t) â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚              â”‚              â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   CODE CHáº¤T    â”‚
                    â”‚   LÆ¯á»¢NG CAO    â”‚
                    â”‚ â€¢ Maintainable â”‚
                    â”‚ â€¢ Scalable     â”‚
                    â”‚ â€¢ Reusable     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### VÃ­ dá»¥ tá»•ng há»£p: Há»‡ thá»‘ng quáº£n lÃ½ nhÃ¢n viÃªn

```java
// ABSTRACTION: Äá»‹nh nghÄ©a interface chung
interface Workable {
    void work();
    double calculateSalary();
}

// ENCAPSULATION: ÄÃ³ng gÃ³i data, kiá»ƒm soÃ¡t truy cáº­p
abstract class Employee implements Workable {
    private String id;           // private - áº©n giáº¥u
    private String name;
    private double baseSalary;

    // Constructor
    public Employee(String id, String name, double baseSalary) {
        this.id = id;
        this.name = name;
        this.baseSalary = baseSalary;
    }

    // Getter - kiá»ƒm soÃ¡t Ä‘á»c
    public String getName() { return name; }
    public double getBaseSalary() { return baseSalary; }

    // Setter vá»›i validation - kiá»ƒm soÃ¡t ghi
    public void setBaseSalary(double salary) {
        if (salary > 0) {
            this.baseSalary = salary;
        }
    }

    // ABSTRACTION: Method chung, implementation á»Ÿ subclass
    public abstract void work();
    public abstract double calculateSalary();
}

// INHERITANCE: Developer káº¿ thá»«a tá»« Employee
class Developer extends Employee {
    private String programmingLanguage;
    private int projectBonus;

    public Developer(String id, String name, double baseSalary, String lang) {
        super(id, name, baseSalary);  // Gá»i constructor cha
        this.programmingLanguage = lang;
    }

    // POLYMORPHISM (Override): CÃ¹ng method, behavior khÃ¡c
    @Override
    public void work() {
        System.out.println(getName() + " is coding in " + programmingLanguage);
    }

    @Override
    public double calculateSalary() {
        return getBaseSalary() + projectBonus;
    }
}

// INHERITANCE: Manager káº¿ thá»«a tá»« Employee
class Manager extends Employee {
    private int teamSize;
    private double managementBonus;

    public Manager(String id, String name, double baseSalary, int teamSize) {
        super(id, name, baseSalary);
        this.teamSize = teamSize;
        this.managementBonus = teamSize * 100; // $100 per team member
    }

    // POLYMORPHISM (Override): CÃ¹ng method, behavior khÃ¡c
    @Override
    public void work() {
        System.out.println(getName() + " is managing a team of " + teamSize);
    }

    @Override
    public double calculateSalary() {
        return getBaseSalary() + managementBonus;
    }
}

// Sá»­ dá»¥ng POLYMORPHISM
class PayrollSystem {
    // Nháº­n báº¥t ká»³ Employee nÃ o (Developer, Manager, ...)
    public void processPayroll(List<Employee> employees) {
        for (Employee emp : employees) {
            emp.work();                    // Polymorphism - má»—i loáº¡i work khÃ¡c nhau
            double salary = emp.calculateSalary(); // Polymorphism
            System.out.println("Salary: $" + salary);
        }
    }
}

// Main
public class Main {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Developer("D001", "John", 5000, "Java"));
        employees.add(new Manager("M001", "Alice", 7000, 5));

        PayrollSystem payroll = new PayrollSystem();
        payroll.processPayroll(employees);

        // Output:
        // John is coding in Java
        // Salary: $5000.0
        // Alice is managing a team of 5
        // Salary: $7500.0
    }
}
```

**PhÃ¢n tÃ­ch vÃ­ dá»¥ trÃªn:**

| TÃ­nh cháº¥t         | Ãp dá»¥ng trong vÃ­ dá»¥                                      |
| ----------------- | -------------------------------------------------------- |
| **Encapsulation** | `private` fields, getter/setter vá»›i validation           |
| **Abstraction**   | `interface Workable`, `abstract class Employee`          |
| **Inheritance**   | `Developer extends Employee`, `Manager extends Employee` |
| **Polymorphism**  | `work()` vÃ  `calculateSalary()` Ä‘Æ°á»£c override khÃ¡c nhau  |

---

### 3.1 Encapsulation (TÃ­nh Ä‘Ã³ng gÃ³i)

#### Äá»‹nh nghÄ©a Ä‘áº§y Ä‘á»§

**Encapsulation** (TÃ­nh Ä‘Ã³ng gÃ³i) lÃ  má»™t trong nhá»¯ng nguyÃªn táº¯c cÆ¡ báº£n nháº¥t cá»§a OOP. NÃ³ bao gá»“m 2 khÃ­a cáº¡nh chÃ­nh:

1. **Bundling** (GÃ³i gá»n): Gom nhÃ³m cÃ¡c **data** (attributes) vÃ  **methods** liÃªn quan vÃ o trong má»™t Ä‘Æ¡n vá»‹ duy nháº¥t gá»i lÃ  **class/object**.

2. **Information Hiding** (áº¨n giáº¥u thÃ´ng tin): Háº¡n cháº¿ quyá»n truy cáº­p trá»±c tiáº¿p vÃ o má»™t sá»‘ thÃ nh pháº§n cá»§a object, chá»‰ cho phÃ©p truy cáº­p thÃ´ng qua cÃ¡c **public methods** (getter/setter).

#### Táº¡i sao gá»i lÃ  "ÄÃ³ng gÃ³i"?

```
HÃ¬nh dung nhÆ° má»™t viÃªn thuá»‘c con nhá»™ng (capsule):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CAPSULE (Class)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     BÃªn trong (private)     â”‚   â”‚
â”‚  â”‚  â€¢ ThÃ nh pháº§n hoáº¡t cháº¥t     â”‚   â”‚
â”‚  â”‚  â€¢ Cáº¥u trÃºc phá»©c táº¡p        â”‚   â”‚
â”‚  â”‚  â€¢ Chi tiáº¿t implementation  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚
â”‚  BÃªn ngoÃ i (public interface):      â”‚
â”‚  â€¢ Uá»‘ng thuá»‘c â†’ Khá»i bá»‡nh           â”‚
â”‚  â€¢ KhÃ´ng cáº§n biáº¿t bÃªn trong cÃ³ gÃ¬   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### CÃ¡c thÃ nh pháº§n cá»§a Encapsulation

```java
class EncapsulatedClass {
    // 1. PRIVATE DATA - áº¨n giáº¥u bÃªn trong
    private String sensitiveData;
    private int internalState;

    // 2. PUBLIC INTERFACE - Cá»­a ngÃµ truy cáº­p
    public String getData() {           // Getter
        return sensitiveData;
    }

    public void setData(String data) {  // Setter vá»›i validation
        if (isValid(data)) {
            this.sensitiveData = data;
        }
    }

    // 3. PRIVATE METHODS - Logic ná»™i bá»™
    private boolean isValid(String data) {
        return data != null && !data.isEmpty();
    }

    // 4. PUBLIC METHODS - HÃ nh vi cÃ´ng khai
    public void performAction() {
        // Sá»­ dá»¥ng private data vÃ  methods
        internalState++;
        processInternal();
    }

    private void processInternal() {
        // Logic phá»©c táº¡p áº©n bÃªn trong
    }
}
```

#### NguyÃªn táº¯c cá»§a Encapsulation

| NguyÃªn táº¯c                 | MÃ´ táº£                         | VÃ­ dá»¥                          |
| -------------------------- | ----------------------------- | ------------------------------ |
| **Data Hiding**            | Äáº·t fields lÃ  `private`       | `private double balance;`      |
| **Controlled Access**      | DÃ¹ng getter/setter            | `getBalance()`, `setBalance()` |
| **Validation**             | Kiá»ƒm tra trÆ°á»›c khi thay Ä‘á»•i   | `if (amount > 0)`              |
| **Single Point of Access** | Má»™t cÃ¡ch duy nháº¥t Ä‘á»ƒ truy cáº­p | Chá»‰ qua methods                |

#### Má»¥c Ä‘Ã­ch

- âœ… **Báº£o vá»‡ dá»¯ liá»‡u** bÃªn trong Object
- âœ… **Kiá»ƒm soÃ¡t** viá»‡c truy cáº­p vÃ  thay Ä‘á»•i dá»¯ liá»‡u
- âœ… TÄƒng tÃ­nh **báº£o máº­t** vÃ  **an toÃ n** cho chÆ°Æ¡ng trÃ¬nh

#### Access Modifiers

```java
public    // Truy cáº­p tá»« má»i nÆ¡i
private   // Chá»‰ truy cáº­p trong class
protected // Truy cáº­p trong class vÃ  class con
```

![Encapsulation](https://statics.cdn.200lab.io/2023/08/oop-encapsulation.jpg)

#### VÃ­ dá»¥: Class Account

```java
class Account {
    // âŒ Private - KhÃ´ng thá»ƒ truy cáº­p trá»±c tiáº¿p tá»« bÃªn ngoÃ i
    private String name;
    private double balance;

    // âœ… Public - CÃ³ thá»ƒ truy cáº­p tá»« bÃªn ngoÃ i
    public Account(String name, double initialBalance) {
        this.name = name;
        this.balance = initialBalance;
    }

    // Getter - Láº¥y thÃ´ng tin
    public String getName() {
        return this.name;
    }

    public double getBalance() {
        return this.balance;
    }

    // Methods - Thao tÃ¡c vá»›i dá»¯ liá»‡u
    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
            System.out.println("Deposited: " + amount);
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            System.out.println("Withdrawn: " + amount);
        } else {
            System.out.println("Insufficient balance!");
        }
    }
}
```

#### Sá»­ dá»¥ng

```java
Account myAccount = new Account("John", 1000);

// âŒ KHÃ”NG thá»ƒ lÃ m Ä‘iá»u nÃ y (vÃ¬ balance lÃ  private)
// myAccount.balance = 999999;

// âœ… Pháº£i sá»­ dá»¥ng methods public
myAccount.deposit(500);      // Deposited: 500
System.out.println(myAccount.getBalance()); // 1500

myAccount.withdraw(200);     // Withdrawn: 200
System.out.println(myAccount.getBalance()); // 1300
```

#### Lá»£i Ã­ch cá»§a Encapsulation

| Lá»£i Ã­ch             | Giáº£i thÃ­ch                                                |
| ------------------- | --------------------------------------------------------- |
| **Data Hiding**     | áº¨n giáº¥u dá»¯ liá»‡u nháº¡y cáº£m                                  |
| **Validation**      | Kiá»ƒm tra dá»¯ liá»‡u trÆ°á»›c khi thay Ä‘á»•i                       |
| **Flexibility**     | Thay Ä‘á»•i implementation mÃ  khÃ´ng áº£nh hÆ°á»Ÿng code bÃªn ngoÃ i |
| **Maintainability** | Dá»… báº£o trÃ¬ vÃ  debug                                       |

#### VÃ­ dá»¥ thá»±c táº¿

```java
class BankAccount {
    private String accountNumber;
    private String pin;
    private double balance;

    // Validate PIN trÆ°á»›c khi withdraw
    public boolean withdraw(String inputPin, double amount) {
        // Báº£o máº­t: Kiá»ƒm tra PIN
        if (!this.pin.equals(inputPin)) {
            System.out.println("Incorrect PIN!");
            return false;
        }

        // Validation: Kiá»ƒm tra sá»‘ dÆ°
        if (amount > this.balance) {
            System.out.println("Insufficient balance!");
            return false;
        }

        // Thá»±c hiá»‡n giao dá»‹ch
        this.balance -= amount;
        // Log transaction (cÃ³ thá»ƒ thÃªm logic phá»©c táº¡p)
        logTransaction("WITHDRAW", amount);
        return true;
    }

    private void logTransaction(String type, double amount) {
        // Logic ghi log phá»©c táº¡p á»Ÿ Ä‘Ã¢y
        System.out.println(type + ": " + amount);
    }
}
```

**Táº¡i sao cáº§n Encapsulation?**

Náº¿u khÃ´ng cÃ³ Encapsulation:

```java
// âŒ KhÃ´ng cÃ³ Encapsulation
class BadAccount {
    public double balance; // Ai cÅ©ng cÃ³ thá»ƒ thay Ä‘á»•i
}

BadAccount acc = new BadAccount();
acc.balance = 1000;
// Ai Ä‘Ã³ cÃ³ thá»ƒ lÃ m Ä‘iá»u nÃ y:
acc.balance = -999999; // Sá»‘ dÆ° Ã¢m?! KhÃ´ng há»£p lÃ½!
```

Vá»›i Encapsulation:

```java
// âœ… CÃ³ Encapsulation
class GoodAccount {
    private double balance;

    public void setBalance(double balance) {
        if (balance >= 0) { // Validation
            this.balance = balance;
        } else {
            System.out.println("Balance cannot be negative!");
        }
    }
}
```

---

### 3.2 Abstraction (TÃ­nh trá»«u tÆ°á»£ng)

#### Äá»‹nh nghÄ©a Ä‘áº§y Ä‘á»§

**Abstraction** (TÃ­nh trá»«u tÆ°á»£ng) lÃ  quÃ¡ trÃ¬nh **áº©n giáº¥u cÃ¡c chi tiáº¿t triá»ƒn khai phá»©c táº¡p** vÃ  chá»‰ **hiá»ƒn thá»‹ nhá»¯ng tÃ­nh nÄƒng cáº§n thiáº¿t** cho ngÆ°á»i dÃ¹ng. NÃ³ táº­p trung vÃ o **"CÃI GÃŒ"** (what) thay vÃ¬ **"NHÆ¯ THáº¾ NÃ€O"** (how).

#### Táº¡i sao gá»i lÃ  "Trá»«u tÆ°á»£ng"?

```
Trá»«u tÆ°á»£ng = Láº¥y ra nhá»¯ng Ä‘áº·c Ä‘iá»ƒm CHUNG, Bá» QUA chi tiáº¿t Cá»¤ THá»‚

VÃ­ dá»¥: KhÃ¡i niá»‡m "Xe" lÃ  trá»«u tÆ°á»£ng
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    "XE" (Abstract)                  â”‚
â”‚                                                     â”‚
â”‚  Äáº·c Ä‘iá»ƒm chung (abstract):                        â”‚
â”‚  â€¢ CÃ³ bÃ¡nh xe                                       â”‚
â”‚  â€¢ CÃ³ thá»ƒ di chuyá»ƒn                                 â”‚
â”‚  â€¢ CÃ³ ngÆ°á»i Ä‘iá»u khiá»ƒn                              â”‚
â”‚                                                     â”‚
â”‚  Chi tiáº¿t cá»¥ thá»ƒ (concrete) - KHÃ”NG quan tÃ¢m:      â”‚
â”‚  â€¢ Xe mÃ¡y: 2 bÃ¡nh, Ä‘á»™ng cÆ¡ xÄƒng                    â”‚
â”‚  â€¢ Ã” tÃ´: 4 bÃ¡nh, Ä‘á»™ng cÆ¡ Ä‘iá»‡n/xÄƒng                 â”‚
â”‚  â€¢ Xe Ä‘áº¡p: 2 bÃ¡nh, sá»©c ngÆ°á»i                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Hai khÃ­a cáº¡nh cá»§a Abstraction

| KhÃ­a cáº¡nh               | MÃ´ táº£                            | CÃ¡ch thá»±c hiá»‡n              |
| ----------------------- | -------------------------------- | --------------------------- |
| **Data Abstraction**    | áº¨n giáº¥u cÃ¡ch data Ä‘Æ°á»£c lÆ°u trá»¯   | Sá»­ dá»¥ng abstract data types |
| **Process Abstraction** | áº¨n giáº¥u cÃ¡ch hoáº¡t Ä‘á»™ng bÃªn trong | Sá»­ dá»¥ng abstract methods    |

#### Abstraction trong thá»±c táº¿

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ATM MACHINE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  NgÆ°á»i dÃ¹ng THáº¤Y (Abstract Interface):             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  [RÃºt tiá»n]  [Gá»­i tiá»n]  [Sá»‘ dÆ°]   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                     â”‚
â”‚  NgÆ°á»i dÃ¹ng KHÃ”NG THáº¤Y (Hidden Implementation):    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  â€¢ Káº¿t ná»‘i database                 â”‚           â”‚
â”‚  â”‚  â€¢ MÃ£ hÃ³a giao dá»‹ch                 â”‚           â”‚
â”‚  â”‚  â€¢ XÃ¡c thá»±c tháº»                     â”‚           â”‚
â”‚  â”‚  â€¢ Giao tiáº¿p vá»›i ngÃ¢n hÃ ng          â”‚           â”‚
â”‚  â”‚  â€¢ CÆ¡ cháº¿ Ä‘áº¿m tiá»n                  â”‚           â”‚
â”‚  â”‚  â€¢ Báº£o máº­t, logging                 â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Levels of Abstraction

```
High Level (Trá»«u tÆ°á»£ng cao)
    â”‚
    â”‚   interface Vehicle { void move(); }
    â”‚           â†“
    â”‚   abstract class Car implements Vehicle { }
    â”‚           â†“
    â”‚   class Tesla extends Car { void move() {...} }
    â”‚           â†“
    â–¼   Actual implementation code
Low Level (Chi tiáº¿t cá»¥ thá»ƒ)
```

#### Má»¥c Ä‘Ã­ch

- âœ… Táº­p trung vÃ o **"cÃ¡i gÃ¬"** thay vÃ¬ **"nhÆ° tháº¿ nÃ o"**
- âœ… Giáº£m Ä‘á»™ phá»©c táº¡p
- âœ… TÄƒng kháº£ nÄƒng tÃ¡i sá»­ dá»¥ng

#### CÃ¡ch thá»±c hiá»‡n Abstraction

1. **Abstract Class** - Class trá»«u tÆ°á»£ng
2. **Interface** - Giao diá»‡n

#### VÃ­ dá»¥ 1: Remote Control (Äiá»u khiá»ƒn tá»« xa)

```java
// Abstract class
abstract class RemoteControl {
    // Abstract method - KhÃ´ng cÃ³ implementation
    abstract void powerOn();
    abstract void powerOff();
    abstract void volumeUp();
    abstract void volumeDown();

    // Concrete method - CÃ³ implementation
    public void showInfo() {
        System.out.println("This is a remote control");
    }
}

// TV Remote
class TVRemote extends RemoteControl {
    void powerOn() {
        System.out.println("TV is turning ON");
        // Logic phá»©c táº¡p Ä‘á»ƒ báº­t TV (user khÃ´ng cáº§n biáº¿t)
    }

    void powerOff() {
        System.out.println("TV is turning OFF");
    }

    void volumeUp() {
        System.out.println("TV volume UP");
    }

    void volumeDown() {
        System.out.println("TV volume DOWN");
    }
}

// AC Remote
class ACRemote extends RemoteControl {
    void powerOn() {
        System.out.println("AC is turning ON");
        // Logic khÃ¡c Ä‘á»ƒ báº­t Ä‘iá»u hÃ²a
    }

    void powerOff() {
        System.out.println("AC is turning OFF");
    }

    void volumeUp() {
        System.out.println("AC temperature UP");
    }

    void volumeDown() {
        System.out.println("AC temperature DOWN");
    }
}
```

**Sá»­ dá»¥ng:**

```java
RemoteControl tvRemote = new TVRemote();
tvRemote.powerOn();  // TV is turning ON
tvRemote.volumeUp(); // TV volume UP

RemoteControl acRemote = new ACRemote();
acRemote.powerOn();  // AC is turning ON
acRemote.volumeUp(); // AC temperature UP
```

**User chá»‰ cáº§n biáº¿t**:

- Nháº¥n nÃºt ON â†’ Thiáº¿t bá»‹ báº­t
- Nháº¥n nÃºt Volume UP â†’ TÄƒng Ã¢m lÆ°á»£ng/nhiá»‡t Ä‘á»™

**User khÃ´ng cáº§n biáº¿t**:

- TÃ­n hiá»‡u há»“ng ngoáº¡i hoáº¡t Ä‘á»™ng tháº¿ nÃ o
- MÃ£ hÃ³a tÃ­n hiá»‡u nhÆ° tháº¿ nÃ o
- Hardware xá»­ lÃ½ tÃ­n hiá»‡u ra sao

#### VÃ­ dá»¥ 2: UIElement

```java
// Abstract class cho UI Elements
abstract class UIElement {
    protected int x, y;
    protected int width, height;

    // Abstract method - Má»—i element render khÃ¡c nhau
    abstract void render();

    // Concrete method - Chung cho táº¥t cáº£ elements
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
    }
}

// Button element
class Button extends UIElement {
    private String label;

    void render() {
        System.out.println("Rendering Button: " + label);
        // Logic váº½ button phá»©c táº¡p
        // - Váº½ hÃ¬nh chá»¯ nháº­t
        // - ThÃªm shadow
        // - Váº½ text
        // - ThÃªm hover effect
    }
}

// Image element
class Image extends UIElement {
    private String imageUrl;

    void render() {
        System.out.println("Rendering Image: " + imageUrl);
        // Logic load vÃ  hiá»ƒn thá»‹ áº£nh phá»©c táº¡p
        // - Táº£i áº£nh tá»« URL
        // - Resize áº£nh
        // - Apply filters
        // - Render lÃªn canvas
    }
}

// TextInput element
class TextInput extends UIElement {
    private String placeholder;

    void render() {
        System.out.println("Rendering TextInput: " + placeholder);
        // Logic váº½ input phá»©c táº¡p
        // - Váº½ border
        // - Váº½ placeholder text
        // - Handle focus state
        // - Cursor animation
    }
}
```

**Sá»­ dá»¥ng:**

```java
List<UIElement> elements = new ArrayList<>();
elements.add(new Button());
elements.add(new Image());
elements.add(new TextInput());

// Render táº¥t cáº£ elements
for (UIElement element : elements) {
    element.render(); // Gá»i method chung, nhÆ°ng má»—i element tá»± xá»­ lÃ½
}
```

#### Interface - Má»™t dáº¡ng Abstraction khÃ¡c

```java
interface Vehicle {
    void start();
    void stop();
    void accelerate();
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car: Turn key, engine starts");
    }

    public void stop() {
        System.out.println("Car: Press brake, engine stops");
    }

    public void accelerate() {
        System.out.println("Car: Press gas pedal");
    }
}

class Bicycle implements Vehicle {
    public void start() {
        System.out.println("Bicycle: Start pedaling");
    }

    public void stop() {
        System.out.println("Bicycle: Use hand brake");
    }

    public void accelerate() {
        System.out.println("Bicycle: Pedal faster");
    }
}
```

#### Abstraction vs Encapsulation

| KhÃ­a cáº¡nh          | Abstraction               | Encapsulation                      |
| ------------------ | ------------------------- | ---------------------------------- |
| **Má»¥c Ä‘Ã­ch**       | áº¨n giáº¥u **complexity**    | áº¨n giáº¥u **data**                   |
| **Focus**          | **What** it does          | **How** it does                    |
| **Implementation** | Abstract class, Interface | Access modifiers (private, public) |
| **Level**          | Design level              | Implementation level               |

#### VÃ­ dá»¥ thá»±c táº¿: ATM Machine

```java
abstract class ATM {
    // User chá»‰ biáº¿t cÃ¡c operations nÃ y
    abstract void checkBalance();
    abstract void withdraw(double amount);
    abstract void deposit(double amount);

    // User KHÃ”NG cáº§n biáº¿t:
    // - Káº¿t ná»‘i database nhÆ° tháº¿ nÃ o
    // - MÃ£ hÃ³a dá»¯ liá»‡u ra sao
    // - XÃ¡c thá»±c tháº» nhÆ° tháº¿ nÃ o
    // - In biÃªn lai tháº¿ nÃ o
}
```

---

### 3.3 Inheritance (TÃ­nh káº¿ thá»«a)

#### Äá»‹nh nghÄ©a Ä‘áº§y Ä‘á»§

**Inheritance** (TÃ­nh káº¿ thá»«a) lÃ  cÆ¡ cháº¿ cho phÃ©p má»™t class (class con) **thá»«a hÆ°á»Ÿng** cÃ¡c attributes vÃ  methods tá»« má»™t class khÃ¡c (class cha). Class con cÃ³ thá»ƒ:

1. **Sá»­ dá»¥ng** cÃ¡c thuá»™c tÃ­nh vÃ  phÆ°Æ¡ng thá»©c cá»§a class cha
2. **Má»Ÿ rá»™ng** báº±ng cÃ¡ch thÃªm thuá»™c tÃ­nh/phÆ°Æ¡ng thá»©c má»›i
3. **Ghi Ä‘Ã¨** (override) cÃ¡c phÆ°Æ¡ng thá»©c cá»§a class cha

#### Táº¡i sao gá»i lÃ  "Káº¿ thá»«a"?

```
Giá»‘ng nhÆ° káº¿ thá»«a trong gia Ä‘Ã¬nh:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                     â”‚
â”‚  ğŸ‘´ Ã”ng bÃ  (Grandparent Class)                     â”‚
â”‚  â€¢ Há»: Nguyá»…n                                       â”‚
â”‚  â€¢ Truyá»n thá»‘ng gia Ä‘Ã¬nh                           â”‚
â”‚           â”‚                                         â”‚
â”‚           â–¼ (káº¿ thá»«a)                              â”‚
â”‚  ğŸ‘¨ Cha máº¹ (Parent Class)                          â”‚
â”‚  â€¢ Há»: Nguyá»…n (káº¿ thá»«a)                            â”‚
â”‚  â€¢ Truyá»n thá»‘ng (káº¿ thá»«a)                          â”‚
â”‚  â€¢ Nghá» nghiá»‡p (má»›i)                               â”‚
â”‚           â”‚                                         â”‚
â”‚           â–¼ (káº¿ thá»«a)                              â”‚
â”‚  ğŸ‘¶ Con cÃ¡i (Child Class)                          â”‚
â”‚  â€¢ Há»: Nguyá»…n (káº¿ thá»«a)                            â”‚
â”‚  â€¢ Truyá»n thá»‘ng (káº¿ thá»«a)                          â”‚
â”‚  â€¢ Nghá» nghiá»‡p (cÃ³ thá»ƒ khÃ¡c - override)            â”‚
â”‚  â€¢ Sá»Ÿ thÃ­ch riÃªng (má»›i)                            â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Thuáº­t ngá»¯ quan trá»ng

| Thuáº­t ngá»¯        | TÃªn khÃ¡c                 | Ã nghÄ©a                           |
| ---------------- | ------------------------ | --------------------------------- |
| **Parent Class** | Base Class, Super Class  | Class cha - class Ä‘Æ°á»£c káº¿ thá»«a    |
| **Child Class**  | Derived Class, Sub Class | Class con - class káº¿ thá»«a         |
| **extends**      | -                        | Keyword Ä‘á»ƒ káº¿ thá»«a (Java)         |
| **super**        | -                        | Tham chiáº¿u Ä‘áº¿n class cha          |
| **@Override**    | -                        | Annotation Ä‘Ã¡nh dáº¥u method ghi Ä‘Ã¨ |

#### CÆ¡ cháº¿ káº¿ thá»«a

```java
class Parent {
    // Nhá»¯ng gÃ¬ CON Ä‘Æ°á»£c káº¿ thá»«a:
    public String publicField;      // âœ… Káº¿ thá»«a
    protected String protectedField; // âœ… Káº¿ thá»«a
    String defaultField;            // âœ… Káº¿ thá»«a (cÃ¹ng package)
    private String privateField;    // âŒ KHÃ”NG káº¿ thá»«a

    public void publicMethod() {}   // âœ… Káº¿ thá»«a
    protected void protectedMethod() {} // âœ… Káº¿ thá»«a
    private void privateMethod() {} // âŒ KHÃ”NG káº¿ thá»«a
}

class Child extends Parent {
    // Tá»± Ä‘á»™ng cÃ³: publicField, protectedField, defaultField
    // Tá»± Ä‘á»™ng cÃ³: publicMethod(), protectedMethod()

    // CÃ³ thá»ƒ thÃªm má»›i
    private String childField;

    // CÃ³ thá»ƒ override
    @Override
    public void publicMethod() {
        super.publicMethod(); // Gá»i method cá»§a cha
        // ThÃªm logic má»›i
    }
}
```

#### Báº£ng tá»•ng há»£p Access Modifiers vÃ  Inheritance

| Modifier    | CÃ¹ng Class | CÃ¹ng Package | Subclass | KhÃ¡c Package |
| ----------- | ---------- | ------------ | -------- | ------------ |
| `public`    | âœ…         | âœ…           | âœ…       | âœ…           |
| `protected` | âœ…         | âœ…           | âœ…       | âŒ           |
| `default`   | âœ…         | âœ…           | âŒ       | âŒ           |
| `private`   | âœ…         | âŒ           | âŒ       | âŒ           |

#### Má»¥c Ä‘Ã­ch

- âœ… **TÃ¡i sá»­ dá»¥ng code** (Code reusability)
- âœ… Giáº£m **duplication** (trÃ¹ng láº·p)
- âœ… Táº¡o **hierarchy** (phÃ¢n cáº¥p) rÃµ rÃ ng

#### VÃ­ dá»¥ 1: Animal Hierarchy

```java
// Parent class
class Animal {
    String name;
    int age;

    void eat() {
        System.out.println(name + " is eating");
    }

    void sleep() {
        System.out.println(name + " is sleeping");
    }

    void makeSound() {
        System.out.println(name + " makes a sound");
    }
}

// Child class 1
class Dog extends Animal {
    String breed;

    // Override method tá»« parent
    @Override
    void makeSound() {
        System.out.println(name + " barks: Woof! Woof!");
    }

    // Method riÃªng cá»§a Dog
    void fetch() {
        System.out.println(name + " is fetching the ball");
    }
}

// Child class 2
class Cat extends Animal {
    boolean isIndoor;

    @Override
    void makeSound() {
        System.out.println(name + " meows: Meow! Meow!");
    }

    // Method riÃªng cá»§a Cat
    void scratch() {
        System.out.println(name + " is scratching");
    }
}

// Child class 3
class Bird extends Animal {
    boolean canFly;

    @Override
    void makeSound() {
        System.out.println(name + " chirps: Tweet! Tweet!");
    }

    void fly() {
        if (canFly) {
            System.out.println(name + " is flying");
        }
    }
}
```

**Sá»­ dá»¥ng:**

```java
Dog dog = new Dog();
dog.name = "Buddy";
dog.age = 3;
dog.breed = "Golden Retriever";

// Methods tá»« Animal (káº¿ thá»«a)
dog.eat();       // Buddy is eating
dog.sleep();     // Buddy is sleeping

// Method override
dog.makeSound(); // Buddy barks: Woof! Woof!

// Method riÃªng cá»§a Dog
dog.fetch();     // Buddy is fetching the ball

Cat cat = new Cat();
cat.name = "Whiskers";
cat.age = 2;
cat.makeSound(); // Whiskers meows: Meow! Meow!
cat.scratch();   // Whiskers is scratching
```

#### Visualization

```
        Animal (Parent)
        â”œâ”€ name
        â”œâ”€ age
        â”œâ”€ eat()
        â”œâ”€ sleep()
        â””â”€ makeSound()
           â†“ (káº¿ thá»«a)
    â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”
    â”‚      â”‚      â”‚
   Dog    Cat   Bird
(+ breed) (+ isIndoor) (+ canFly)
(+ fetch()) (+ scratch()) (+ fly())
```

#### Loáº¡i Inheritance

##### 1. Single Inheritance (ÄÆ¡n káº¿ thá»«a)

Má»™t class chá»‰ káº¿ thá»«a tá»« **má»™t** parent class duy nháº¥t.

```java
class Vehicle {
    void start() { }
}

class Car extends Vehicle {
    // Car chá»‰ káº¿ thá»«a tá»« Vehicle
}
```

##### 2. Multiple Inheritance (Äa káº¿ thá»«a)

Má»™t class káº¿ thá»«a tá»« **nhiá»u** parent classes.

> âš ï¸ **LÆ°u Ã½**: Java **KHÃ”NG** há»— trá»£ multiple inheritance vá»›i classes (Ä‘á»ƒ trÃ¡nh Diamond Problem)

```java
// âŒ KHÃ”NG thá»ƒ lÃ m Ä‘iá»u nÃ y trong Java
class FlyingCar extends Car, Aircraft {
    // ERROR: Multiple inheritance not supported
}
```

**Giáº£i phÃ¡p**: Sá»­ dá»¥ng **Interface**

```java
interface Flyable {
    void fly();
}

interface Drivable {
    void drive();
}

// âœ… CÃ³ thá»ƒ implement nhiá»u interfaces
class FlyingCar implements Flyable, Drivable {
    public void fly() {
        System.out.println("Flying in the sky");
    }

    public void drive() {
        System.out.println("Driving on the road");
    }
}
```

#### "Is-a" Relationship

"Is-a" giÃºp xÃ¡c Ä‘á»‹nh khi nÃ o nÃªn dÃ¹ng káº¿ thá»«a.

```
Dog IS-A Animal          âœ… ÄÃºng â†’ Dog extends Animal
Car IS-A Vehicle         âœ… ÄÃºng â†’ Car extends Vehicle
Button IS-A UIElement    âœ… ÄÃºng â†’ Button extends UIElement

Dog IS-A Car             âŒ Sai â†’ KhÃ´ng nÃªn káº¿ thá»«a
```

**VÃ­ dá»¥ thá»±c táº¿:**

```java
// Shape hierarchy
class Shape {
    String color;
    void draw() { }
}

class Circle extends Shape {
    // Circle IS-A Shape âœ…
    double radius;
}

class Rectangle extends Shape {
    // Rectangle IS-A Shape âœ…
    double width;
    double height;
}

class Triangle extends Shape {
    // Triangle IS-A Shape âœ…
    double base;
    double height;
}
```

#### "Has-a" Relationship (Composition)

"Has-a" lÃ  **thay tháº¿** cho káº¿ thá»«a, sá»­ dá»¥ng **composition** (phá»‘i há»£p).

```java
// âŒ KhÃ´ng nÃªn: Car extends Engine (Car IS-A Engine? Sai!)

// âœ… NÃªn: Car HAS-A Engine
class Engine {
    int horsepower;
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    Engine engine; // Car HAS-A Engine

    Car() {
        this.engine = new Engine();
    }

    void start() {
        engine.start();
        System.out.println("Car started");
    }
}
```

**ThÃªm vÃ­ dá»¥ Has-a:**

```java
class Customer {
    String name;
    String email;
}

class Product {
    String name;
    double price;
}

class Order {
    Customer customer;    // Order HAS-A Customer
    List<Product> products; // Order HAS-A List of Products
    double totalAmount;
}
```

#### Khi nÃ o dÃ¹ng Inheritance vs Composition?

```
Inheritance (Is-a):
âœ… CÃ³ má»‘i quan há»‡ rÃµ rÃ ng "is-a"
âœ… Child class lÃ  má»™t dáº¡ng Ä‘áº·c biá»‡t cá»§a Parent class
âœ… Cáº§n override methods tá»« parent

Composition (Has-a):
âœ… Cáº§n tÃ­nh linh hoáº¡t cao
âœ… Muá»‘n trÃ¡nh tight coupling
âœ… Cáº§n káº¿t há»£p nhiá»u functionalities
```

---

### 3.4 Polymorphism (TÃ­nh Ä‘a hÃ¬nh)

#### Äá»‹nh nghÄ©a Ä‘áº§y Ä‘á»§

**Polymorphism** = "Poly" (nhiá»u) + "Morph" (hÃ¬nh dáº¡ng) = **Nhiá»u hÃ¬nh dáº¡ng**

Polymorphism lÃ  kháº£ nÄƒng cá»§a má»™t Ä‘á»‘i tÆ°á»£ng cÃ³ thá»ƒ **thá»ƒ hiá»‡n nhiá»u hÃ¬nh thÃ¡i khÃ¡c nhau**. CÃ¹ng má»™t hÃ nh Ä‘á»™ng (method) nhÆ°ng cÃ³ thá»ƒ cÃ³ **nhiá»u cÃ¡ch thá»±c hiá»‡n khÃ¡c nhau** tÃ¹y thuá»™c vÃ o Ä‘á»‘i tÆ°á»£ng thá»±c thi.

#### Táº¡i sao gá»i lÃ  "Äa hÃ¬nh"?

```
VÃ­ dá»¥: HÃ nh Ä‘á»™ng "NÃ³i" (speak)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                     â”‚
â”‚  CÃ¹ng má»™t hÃ nh Ä‘á»™ng: speak()                       â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  NgÆ°á»i  â”‚  â”‚   ChÃ³   â”‚  â”‚   MÃ¨o   â”‚            â”‚
â”‚  â”‚ speak() â”‚  â”‚ speak() â”‚  â”‚ speak() â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚
â”‚       â”‚            â”‚            â”‚                  â”‚
â”‚       â–¼            â–¼            â–¼                  â”‚
â”‚   "Xin chÃ o"   "GÃ¢u gÃ¢u"   "Meo meo"              â”‚
â”‚                                                     â”‚
â”‚  â†’ CÃ¹ng method name, KHÃC behavior                 â”‚
â”‚  â†’ ÄÃ¢y chÃ­nh lÃ  POLYMORPHISM                       â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Hai loáº¡i Polymorphism

```
                    POLYMORPHISM
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                             â”‚
          â–¼                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STATIC POLYMORPHISM â”‚    â”‚DYNAMIC POLYMORPHISM â”‚
â”‚   (Compile-time)    â”‚    â”‚    (Runtime)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     â”‚    â”‚                     â”‚
â”‚ â€¢ Method Overloadingâ”‚    â”‚ â€¢ Method Overriding â”‚
â”‚ â€¢ Operator Overload â”‚    â”‚ â€¢ Virtual methods   â”‚
â”‚                     â”‚    â”‚                     â”‚
â”‚ Quyáº¿t Ä‘á»‹nh lÃºc      â”‚    â”‚ Quyáº¿t Ä‘á»‹nh lÃºc      â”‚
â”‚ COMPILE             â”‚    â”‚ RUNTIME             â”‚
â”‚                     â”‚    â”‚                     â”‚
â”‚ CÃ¹ng class          â”‚    â”‚ Parent-Child class  â”‚
â”‚ KhÃ¡c parameters     â”‚    â”‚ CÃ¹ng signature      â”‚
â”‚                     â”‚    â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Báº£ng so sÃ¡nh 2 loáº¡i Polymorphism

| TiÃªu chÃ­        | Static (Overloading) | Dynamic (Overriding)        |
| --------------- | -------------------- | --------------------------- |
| **Thá»i Ä‘iá»ƒm**   | Compile-time         | Runtime                     |
| **Vá»‹ trÃ­**      | CÃ¹ng má»™t class       | Parent vÃ  Child class       |
| **Method name** | Giá»‘ng nhau           | Giá»‘ng nhau                  |
| **Parameters**  | KHÃC nhau            | GIá»NG nhau                  |
| **Return type** | CÃ³ thá»ƒ khÃ¡c          | Pháº£i giá»‘ng (hoáº·c covariant) |
| **Keyword**     | KhÃ´ng cáº§n            | `@Override`                 |
| **Binding**     | Early binding        | Late binding                |

#### VÃ­ dá»¥ minh há»a sá»± khÃ¡c biá»‡t

```java
class Example {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OVERLOADING (Static Polymorphism)
    // CÃ¹ng class, cÃ¹ng tÃªn, KHÃC tham sá»‘
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    void print(String s) {
        System.out.println("String: " + s);
    }

    void print(int i) {           // KhÃ¡c kiá»ƒu tham sá»‘
        System.out.println("Int: " + i);
    }

    void print(String s, int n) { // KhÃ¡c sá»‘ lÆ°á»£ng tham sá»‘
        for (int i = 0; i < n; i++) {
            System.out.println(s);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OVERRIDING (Dynamic Polymorphism)
// Parent-Child, cÃ¹ng tÃªn, CÃ™NG tham sá»‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    void speak() {              // CÃ¹ng signature vá»›i parent
        System.out.println("Woof!");
    }
}

class Cat extends Animal {
    @Override
    void speak() {              // CÃ¹ng signature vá»›i parent
        System.out.println("Meow!");
    }
}
```

![Polymorphism](https://statics.cdn.200lab.io/2023/08/oop-polymorphism.jpg)

---

#### Static Polymorphism (Method Overloading)

**Äá»‹nh nghÄ©a**: Nhiá»u methods **cÃ¹ng tÃªn** nhÆ°ng **khÃ¡c tham sá»‘** trong cÃ¹ng má»™t class.

**Äiá»u kiá»‡n Ä‘á»ƒ Overloading:**

- CÃ¹ng tÃªn method
- KhÃ¡c sá»‘ lÆ°á»£ng tham sá»‘, HOáº¶C
- KhÃ¡c kiá»ƒu dá»¯ liá»‡u tham sá»‘

```java
class Calculator {
    // Method 1: Cá»™ng 2 sá»‘ int
    int add(int a, int b) {
        return a + b;
    }

    // Method 2: Cá»™ng 3 sá»‘ int (khÃ¡c sá»‘ lÆ°á»£ng tham sá»‘)
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method 3: Cá»™ng 2 sá»‘ double (khÃ¡c kiá»ƒu tham sá»‘)
    double add(double a, double b) {
        return a + b;
    }

    // Method 4: Cá»™ng array
    int add(int[] numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
}
```

**Sá»­ dá»¥ng:**

```java
Calculator calc = new Calculator();

System.out.println(calc.add(5, 3));           // 8 (Method 1)
System.out.println(calc.add(5, 3, 2));        // 10 (Method 2)
System.out.println(calc.add(5.5, 3.2));       // 8.7 (Method 3)
System.out.println(calc.add(new int[]{1,2,3})); // 6 (Method 4)
```

**VÃ­ dá»¥ thá»±c táº¿: Print method**

```java
class Printer {
    void print(String text) {
        System.out.println("Text: " + text);
    }

    void print(int number) {
        System.out.println("Number: " + number);
    }

    void print(String text, int copies) {
        for (int i = 0; i < copies; i++) {
            System.out.println("Text: " + text);
        }
    }

    void print(String[] texts) {
        for (String text : texts) {
            System.out.println("Text: " + text);
        }
    }
}
```

**Lá»£i Ã­ch cá»§a Method Overloading:**

- âœ… Code dá»… Ä‘á»c, dá»… nhá»› (cÃ¹ng tÃªn method)
- âœ… TÄƒng tÃ­nh linh hoáº¡t
- âœ… Giáº£m sá»± phá»©c táº¡p

---

#### Dynamic Polymorphism (Method Overriding)

**Äá»‹nh nghÄ©a**: Child class **Ä‘á»‹nh nghÄ©a láº¡i** (ghi Ä‘Ã¨) method tá»« Parent class vá»›i **cÃ¹ng signature** (tÃªn, tham sá»‘, return type).

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }

    void move() {
        System.out.println("Animal moves");
    }
}

class Dog extends Animal {
    // Override method makeSound()
    @Override
    void makeSound() {
        System.out.println("Dog barks: Woof! Woof!");
    }

    @Override
    void move() {
        System.out.println("Dog runs on 4 legs");
    }
}

class Bird extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bird chirps: Tweet! Tweet!");
    }

    @Override
    void move() {
        System.out.println("Bird flies in the sky");
    }
}

class Fish extends Animal {
    @Override
    void makeSound() {
        System.out.println("Fish makes bubbles: Blub! Blub!");
    }

    @Override
    void move() {
        System.out.println("Fish swims in water");
    }
}
```

**Sá»­ dá»¥ng - Runtime Polymorphism:**

````java
// Parent reference, Child object
Animal animal1 = new Dog();
Animal animal2 = new Bird();
Animal animal3 = new Fish();

// CÃ¹ng method call, nhÆ°ng behavior khÃ¡c nhau
animal1.makeSound(); // Dog barks: Woof! Woof!
animal2.makeSound(); // Bird chirps: Tweet! Tweet!
animal3.makeSound(); // Fish makes bubbles: Blub! Blub!

animal1.move();      // Dog runs on 4 legs
animal2.move();      // Bird flies in the sky
animal3.move();      // Fish swims in water

**
VÃ­ dá»¥ thá»±c táº¿: Payment System**

```java
abstract class Payment {
    protected double amount;

    abstract void processPayment();
    abstract void refund();
}

class CreditCardPayment extends Payment {
    private String cardNumber;

    @Override
    void processPayment() {
        System.out.println("Processing credit card payment: $" + amount);
        // Logic xá»­ lÃ½ tháº» tÃ­n dá»¥ng
        // - Validate card
        // - Connect to payment gateway
        // - Charge card
    }

    @Override
    void refund() {
        System.out.println("Refunding to credit card: $" + amount);
    }
}

class PayPalPayment extends Payment {
    private String email;

    @Override
    void processPayment() {
        System.out.println("Processing PayPal payment: $" + amount);
        // Logic xá»­ lÃ½ PayPal
        // - Redirect to PayPal
        // - Authenticate user
        // - Complete transaction
    }

    @Override
    void refund() {
        System.out.println("Refunding to PayPal account: $" + amount);
    }
}

class CryptoPayment extends Payment {
    private String walletAddress;

    @Override
    void processPayment() {
        System.out.println("Processing crypto payment: $" + amount);
        // Logic xá»­ lÃ½ crypto
        // - Generate wallet address
        // - Wait for blockchain confirmation
    }

    @Override
    void refund() {
        System.out.println("Refunding to crypto wallet: $" + amount);
    }
}
````

**Sá»­ dá»¥ng Polymorphism trong thá»±c táº¿:**

```java
class PaymentProcessor {
    // Nháº­n báº¥t ká»³ loáº¡i Payment nÃ o
    void process(Payment payment) {
        payment.processPayment();
    }

    void processMultiple(List<Payment> payments) {
        for (Payment payment : payments) {
            payment.processPayment(); // Polymorphism!
        }
    }
}

// Usage
PaymentProcessor processor = new PaymentProcessor();

Payment creditCard = new CreditCardPayment();
Payment paypal = new PayPalPayment();
Payment crypto = new CryptoPayment();

processor.process(creditCard); // Processing credit card payment
processor.process(paypal);     // Processing PayPal payment
processor.process(crypto);     // Processing crypto payment
```

#### So sÃ¡nh Overloading vs Overriding

| TiÃªu chÃ­             | Overloading           | Overriding                  |
| -------------------- | --------------------- | --------------------------- |
| **Loáº¡i**             | Static (Compile-time) | Dynamic (Runtime)           |
| **Vá»‹ trÃ­**           | CÃ¹ng class            | Parent-Child classes        |
| **Method signature** | KhÃ¡c tham sá»‘          | Giá»‘ng hoÃ n toÃ n             |
| **Return type**      | CÃ³ thá»ƒ khÃ¡c           | Pháº£i giá»‘ng (hoáº·c covariant) |
| **Access modifier**  | CÃ³ thá»ƒ khÃ¡c           | KhÃ´ng Ä‘Æ°á»£c restrictive hÆ¡n  |
| **Annotation**       | KhÃ´ng cáº§n             | `@Override` (recommended)   |

#### Lá»£i Ã­ch cá»§a Polymorphism

| Lá»£i Ã­ch              | Giáº£i thÃ­ch                                        |
| -------------------- | ------------------------------------------------- |
| **Flexibility**      | Code linh hoáº¡t, dá»… má»Ÿ rá»™ng                        |
| **Maintainability**  | Dá»… báº£o trÃ¬, thÃªm loáº¡i má»›i khÃ´ng áº£nh hÆ°á»Ÿng code cÅ© |
| **Loose Coupling**   | Giáº£m sá»± phá»¥ thuá»™c giá»¯a cÃ¡c components             |
| **Code Reusability** | TÃ¡i sá»­ dá»¥ng code hiá»‡u quáº£                         |

---

## 3.5 VÃ­ dá»¥ 4 tÃ­nh cháº¥t OOP báº±ng C++ vÃ  JavaScript

### ğŸ”· C++ Examples

#### Encapsulation trong C++

```cpp
#include <iostream>
#include <string>
using namespace std;

class BankAccount {
private:
    // Private data - áº©n giáº¥u bÃªn trong
    string accountNumber;
    string ownerName;
    double balance;

public:
    // Constructor
    BankAccount(string accNum, string name, double initialBalance) {
        accountNumber = accNum;
        ownerName = name;
        balance = (initialBalance >= 0) ? initialBalance : 0;
    }

    // Getter methods - kiá»ƒm soÃ¡t Ä‘á»c
    string getAccountNumber() const {
        return accountNumber;
    }

    string getOwnerName() const {
        return ownerName;
    }

    double getBalance() const {
        return balance;
    }

    // Public methods vá»›i validation - kiá»ƒm soÃ¡t ghi
    bool deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout << "Deposited: $" << amount << endl;
            return true;
        }
        cout << "Invalid deposit amount!" << endl;
        return false;
    }

    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            cout << "Withdrawn: $" << amount << endl;
            return true;
        }
        cout << "Insufficient balance or invalid amount!" << endl;
        return false;
    }
};

int main() {
    BankAccount account("ACC001", "John Doe", 1000);

    // âŒ KhÃ´ng thá»ƒ truy cáº­p trá»±c tiáº¿p
    // account.balance = 999999; // Error: 'balance' is private

    // âœ… Pháº£i dÃ¹ng public methods
    account.deposit(500);                    // Deposited: $500
    cout << "Balance: $" << account.getBalance() << endl; // Balance: $1500
    account.withdraw(200);                   // Withdrawn: $200

    return 0;
}
```

#### Abstraction trong C++

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Abstract class (cÃ³ Ã­t nháº¥t 1 pure virtual function)
class Shape {
protected:
    string color;

public:
    Shape(string c) : color(c) {}

    // Pure virtual functions - abstract methods
    virtual double calculateArea() = 0;
    virtual double calculatePerimeter() = 0;
    virtual void draw() = 0;

    // Concrete method
    void displayColor() {
        cout << "Color: " << color << endl;
    }

    // Virtual destructor
    virtual ~Shape() {}
};

// Concrete class - Circle
class Circle : public Shape {
private:
    double radius;

public:
    Circle(string c, double r) : Shape(c), radius(r) {}

    double calculateArea() override {
        return M_PI * radius * radius;
    }

    double calculatePerimeter() override {
        return 2 * M_PI * radius;
    }

    void draw() override {
        cout << "Drawing a " << color << " circle with radius " << radius << endl;
    }
};

// Concrete class - Rectangle
class Rectangle : public Shape {
private:
    double width, height;

public:
    Rectangle(string c, double w, double h) : Shape(c), width(w), height(h) {}

    double calculateArea() override {
        return width * height;
    }

    double calculatePerimeter() override {
        return 2 * (width + height);
    }

    void draw() override {
        cout << "Drawing a " << color << " rectangle " << width << "x" << height << endl;
    }
};

int main() {
    // âŒ KhÃ´ng thá»ƒ táº¡o instance cá»§a abstract class
    // Shape shape("red"); // Error!

    // âœ… Táº¡o instance cá»§a concrete classes
    Shape* circle = new Circle("red", 5);
    Shape* rectangle = new Rectangle("blue", 4, 6);

    // User chá»‰ cáº§n biáº¿t interface, khÃ´ng cáº§n biáº¿t implementation
    circle->draw();                    // Drawing a red circle with radius 5
    cout << "Area: " << circle->calculateArea() << endl;

    rectangle->draw();                 // Drawing a blue rectangle 4x6
    cout << "Area: " << rectangle->calculateArea() << endl;

    delete circle;
    delete rectangle;
    return 0;
}
```

#### Inheritance trong C++

```cpp
#include <iostream>
#include <string>
using namespace std;

// Base class (Parent)
class Vehicle {
protected:
    string brand;
    int year;
    double price;

public:
    Vehicle(string b, int y, double p) : brand(b), year(y), price(p) {}

    void displayInfo() {
        cout << "Brand: " << brand << ", Year: " << year << ", Price: $" << price << endl;
    }

    virtual void start() {
        cout << "Vehicle is starting..." << endl;
    }

    virtual void stop() {
        cout << "Vehicle is stopping..." << endl;
    }
};

// Derived class (Child) - Car
class Car : public Vehicle {
private:
    int numDoors;
    string fuelType;

public:
    // Gá»i constructor cá»§a parent class
    Car(string b, int y, double p, int doors, string fuel)
        : Vehicle(b, y, p), numDoors(doors), fuelType(fuel) {}

    // Override method
    void start() override {
        cout << brand << " car: Turn key, engine starts. Vroom!" << endl;
    }

    void stop() override {
        cout << brand << " car: Press brake, engine stops." << endl;
    }

    // Method riÃªng cá»§a Car
    void honk() {
        cout << brand << " car: Beep beep!" << endl;
    }

    void displayCarInfo() {
        displayInfo(); // Gá»i method tá»« parent
        cout << "Doors: " << numDoors << ", Fuel: " << fuelType << endl;
    }
};

// Derived class - Motorcycle
class Motorcycle : public Vehicle {
private:
    string type; // sport, cruiser, touring

public:
    Motorcycle(string b, int y, double p, string t)
        : Vehicle(b, y, p), type(t) {}

    void start() override {
        cout << brand << " motorcycle: Kick start. Vroom vroom!" << endl;
    }

    void stop() override {
        cout << brand << " motorcycle: Apply brakes." << endl;
    }

    void wheelie() {
        cout << brand << " motorcycle: Doing a wheelie!" << endl;
    }
};

int main() {
    Car myCar("Toyota", 2023, 25000, 4, "Gasoline");
    Motorcycle myBike("Harley", 2022, 15000, "Cruiser");

    // Sá»­ dá»¥ng methods káº¿ thá»«a
    myCar.displayCarInfo();
    myCar.start();      // Toyota car: Turn key, engine starts. Vroom!
    myCar.honk();       // Toyota car: Beep beep!

    cout << endl;

    myBike.displayInfo();
    myBike.start();     // Harley motorcycle: Kick start. Vroom vroom!
    myBike.wheelie();   // Harley motorcycle: Doing a wheelie!

    return 0;
}
```

#### Polymorphism trong C++

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPILE-TIME POLYMORPHISM (Method Overloading)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Calculator {
public:
    // Overloading: cÃ¹ng tÃªn, khÃ¡c tham sá»‘
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    string add(string a, string b) {
        return a + b;
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RUNTIME POLYMORPHISM (Method Overriding)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Animal {
public:
    virtual void speak() {
        cout << "Animal makes a sound" << endl;
    }

    virtual void move() {
        cout << "Animal moves" << endl;
    }

    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "Dog: Woof! Woof!" << endl;
    }

    void move() override {
        cout << "Dog runs on 4 legs" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat: Meow! Meow!" << endl;
    }

    void move() override {
        cout << "Cat walks gracefully" << endl;
    }
};

class Bird : public Animal {
public:
    void speak() override {
        cout << "Bird: Tweet! Tweet!" << endl;
    }

    void move() override {
        cout << "Bird flies in the sky" << endl;
    }
};

// Function nháº­n base class pointer - Polymorphism!
void makeAnimalSpeak(Animal* animal) {
    animal->speak(); // Gá»i Ä‘Ãºng method cá»§a derived class
}

int main() {
    // Compile-time Polymorphism
    Calculator calc;
    cout << "=== Method Overloading ===" << endl;
    cout << "add(5, 3) = " << calc.add(5, 3) << endl;           // 8
    cout << "add(5.5, 3.2) = " << calc.add(5.5, 3.2) << endl;   // 8.7
    cout << "add(1, 2, 3) = " << calc.add(1, 2, 3) << endl;     // 6
    cout << "add(\"Hello\", \" World\") = " << calc.add("Hello", " World") << endl;

    cout << "\n=== Method Overriding ===" << endl;

    // Runtime Polymorphism
    // Parent pointer, Child object
    Animal* animals[3];
    animals[0] = new Dog();
    animals[1] = new Cat();
    animals[2] = new Bird();

    // CÃ¹ng method call, khÃ¡c behavior
    for (int i = 0; i < 3; i++) {
        makeAnimalSpeak(animals[i]);
        animals[i]->move();
        cout << "---" << endl;
    }

    // Cleanup
    for (int i = 0; i < 3; i++) {
        delete animals[i];
    }

    return 0;
}
```

---

### ğŸŸ¨ JavaScript Examples

#### Encapsulation trong JavaScript (ES6+)

```javascript
// Sá»­ dá»¥ng private fields (#) - ES2022+
class BankAccount {
  // Private fields
  #accountNumber;
  #ownerName;
  #balance;

  constructor(accountNumber, ownerName, initialBalance) {
    this.#accountNumber = accountNumber;
    this.#ownerName = ownerName;
    this.#balance = initialBalance >= 0 ? initialBalance : 0;
  }

  // Getter methods
  get accountNumber() {
    return this.#accountNumber;
  }

  get ownerName() {
    return this.#ownerName;
  }

  get balance() {
    return this.#balance;
  }

  // Public methods vá»›i validation
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      console.log(`Deposited: $${amount}`);
      return true;
    }
    console.log("Invalid deposit amount!");
    return false;
  }

  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      console.log(`Withdrawn: $${amount}`);
      return true;
    }
    console.log("Insufficient balance or invalid amount!");
    return false;
  }

  // Private method
  #logTransaction(type, amount) {
    console.log(`[LOG] ${type}: $${amount} at ${new Date().toISOString()}`);
  }
}

// Sá»­ dá»¥ng
const account = new BankAccount("ACC001", "John Doe", 1000);

// âŒ KhÃ´ng thá»ƒ truy cáº­p private fields
// console.log(account.#balance); // SyntaxError

// âœ… Pháº£i dÃ¹ng public methods/getters
account.deposit(500); // Deposited: $500
console.log(`Balance: $${account.balance}`); // Balance: $1500
account.withdraw(200); // Withdrawn: $200
```

```javascript
// CÃ¡ch khÃ¡c: Sá»­ dá»¥ng Closure (ES5 compatible)
function createBankAccount(accountNumber, ownerName, initialBalance) {
  // Private variables (closure)
  let _balance = initialBalance >= 0 ? initialBalance : 0;

  return {
    // Public getters
    getAccountNumber: () => accountNumber,
    getOwnerName: () => ownerName,
    getBalance: () => _balance,

    // Public methods
    deposit(amount) {
      if (amount > 0) {
        _balance += amount;
        console.log(`Deposited: $${amount}`);
        return true;
      }
      return false;
    },

    withdraw(amount) {
      if (amount > 0 && amount <= _balance) {
        _balance -= amount;
        console.log(`Withdrawn: $${amount}`);
        return true;
      }
      return false;
    },
  };
}

const account2 = createBankAccount("ACC002", "Jane", 500);
account2.deposit(100);
console.log(account2.getBalance()); // 600
```

#### Abstraction trong JavaScript

```javascript
// Abstract class simulation trong JavaScript
class Shape {
  constructor(color) {
    if (new.target === Shape) {
      throw new Error("Cannot instantiate abstract class Shape directly!");
    }
    this.color = color;
  }

  // Abstract methods - pháº£i Ä‘Æ°á»£c override
  calculateArea() {
    throw new Error("Method calculateArea() must be implemented!");
  }

  calculatePerimeter() {
    throw new Error("Method calculatePerimeter() must be implemented!");
  }

  draw() {
    throw new Error("Method draw() must be implemented!");
  }

  // Concrete method
  displayColor() {
    console.log(`Color: ${this.color}`);
  }
}

// Concrete class - Circle
class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  calculateArea() {
    return Math.PI * this.radius ** 2;
  }

  calculatePerimeter() {
    return 2 * Math.PI * this.radius;
  }

  draw() {
    console.log(`Drawing a ${this.color} circle with radius ${this.radius}`);
  }
}

// Concrete class - Rectangle
class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }

  calculateArea() {
    return this.width * this.height;
  }

  calculatePerimeter() {
    return 2 * (this.width + this.height);
  }

  draw() {
    console.log(`Drawing a ${this.color} rectangle ${this.width}x${this.height}`);
  }
}

// Sá»­ dá»¥ng
// const shape = new Shape('red'); // âŒ Error: Cannot instantiate abstract class

const circle = new Circle("red", 5);
const rectangle = new Rectangle("blue", 4, 6);

// User chá»‰ cáº§n biáº¿t interface
circle.draw(); // Drawing a red circle with radius 5
console.log(`Area: ${circle.calculateArea().toFixed(2)}`); // Area: 78.54

rectangle.draw(); // Drawing a blue rectangle 4x6
console.log(`Area: ${rectangle.calculateArea()}`); // Area: 24
```

```javascript
// Abstraction vá»›i Interface pattern
// JavaScript khÃ´ng cÃ³ interface, nhÆ°ng cÃ³ thá»ƒ simulate

const VehicleInterface = {
  start: function () {
    throw new Error("start() must be implemented");
  },
  stop: function () {
    throw new Error("stop() must be implemented");
  },
  accelerate: function () {
    throw new Error("accelerate() must be implemented");
  },
};

class Car {
  constructor(brand) {
    this.brand = brand;
    // Verify interface implementation
    Object.keys(VehicleInterface).forEach((method) => {
      if (typeof this[method] !== "function") {
        throw new Error(`${this.constructor.name} must implement ${method}()`);
      }
    });
  }

  start() {
    console.log(`${this.brand}: Engine starts. Vroom!`);
  }

  stop() {
    console.log(`${this.brand}: Engine stops.`);
  }

  accelerate() {
    console.log(`${this.brand}: Speeding up!`);
  }
}

const myCar = new Car("Toyota");
myCar.start(); // Toyota: Engine starts. Vroom!
```

#### Inheritance trong JavaScript

```javascript
// Parent class
class Vehicle {
  constructor(brand, year, price) {
    this.brand = brand;
    this.year = year;
    this.price = price;
  }

  displayInfo() {
    console.log(`Brand: ${this.brand}, Year: ${this.year}, Price: $${this.price}`);
  }

  start() {
    console.log("Vehicle is starting...");
  }

  stop() {
    console.log("Vehicle is stopping...");
  }
}

// Child class - Car
class Car extends Vehicle {
  constructor(brand, year, price, numDoors, fuelType) {
    super(brand, year, price); // Gá»i constructor cá»§a parent
    this.numDoors = numDoors;
    this.fuelType = fuelType;
  }

  // Override methods
  start() {
    console.log(`${this.brand} car: Turn key, engine starts. Vroom!`);
  }

  stop() {
    console.log(`${this.brand} car: Press brake, engine stops.`);
  }

  // Method riÃªng cá»§a Car
  honk() {
    console.log(`${this.brand} car: Beep beep!`);
  }

  displayCarInfo() {
    super.displayInfo(); // Gá»i method tá»« parent
    console.log(`Doors: ${this.numDoors}, Fuel: ${this.fuelType}`);
  }
}

// Child class - Motorcycle
class Motorcycle extends Vehicle {
  constructor(brand, year, price, type) {
    super(brand, year, price);
    this.type = type;
  }

  start() {
    console.log(`${this.brand} motorcycle: Kick start. Vroom vroom!`);
  }

  stop() {
    console.log(`${this.brand} motorcycle: Apply brakes.`);
  }

  wheelie() {
    console.log(`${this.brand} motorcycle: Doing a wheelie!`);
  }
}

// Sá»­ dá»¥ng
const myCar = new Car("Toyota", 2023, 25000, 4, "Gasoline");
const myBike = new Motorcycle("Harley", 2022, 15000, "Cruiser");

myCar.displayCarInfo();
// Brand: Toyota, Year: 2023, Price: $25000
// Doors: 4, Fuel: Gasoline

myCar.start(); // Toyota car: Turn key, engine starts. Vroom!
myCar.honk(); // Toyota car: Beep beep!

console.log("---");

myBike.displayInfo(); // Brand: Harley, Year: 2022, Price: $15000
myBike.start(); // Harley motorcycle: Kick start. Vroom vroom!
myBike.wheelie(); // Harley motorcycle: Doing a wheelie!
```

#### Polymorphism trong JavaScript

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METHOD OVERLOADING (Simulated - JS khÃ´ng há»— trá»£ native)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Calculator {
  // JavaScript khÃ´ng cÃ³ method overloading thá»±c sá»±
  // NhÆ°ng cÃ³ thá»ƒ simulate báº±ng cÃ¡ch kiá»ƒm tra arguments

  add(...args) {
    // Kiá»ƒm tra sá»‘ lÆ°á»£ng vÃ  kiá»ƒu tham sá»‘
    if (args.length === 0) {
      return 0;
    }

    if (args.every((arg) => typeof arg === "number")) {
      return args.reduce((sum, num) => sum + num, 0);
    }

    if (args.every((arg) => typeof arg === "string")) {
      return args.join("");
    }

    if (Array.isArray(args[0])) {
      return args[0].reduce((sum, num) => sum + num, 0);
    }

    throw new Error("Invalid arguments");
  }
}

const calc = new Calculator();
console.log("=== Method Overloading (Simulated) ===");
console.log("add(5, 3) =", calc.add(5, 3)); // 8
console.log("add(1, 2, 3, 4) =", calc.add(1, 2, 3, 4)); // 10
console.log('add("Hello", " ", "World") =', calc.add("Hello", " ", "World")); // Hello World
console.log("add([1, 2, 3]) =", calc.add([1, 2, 3])); // 6

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METHOD OVERRIDING (Runtime Polymorphism)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound`);
  }

  move() {
    console.log(`${this.name} moves`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name}: Woof! Woof!`);
  }

  move() {
    console.log(`${this.name} runs on 4 legs`);
  }
}

class Cat extends Animal {
  speak() {
    console.log(`${this.name}: Meow! Meow!`);
  }

  move() {
    console.log(`${this.name} walks gracefully`);
  }
}

class Bird extends Animal {
  speak() {
    console.log(`${this.name}: Tweet! Tweet!`);
  }

  move() {
    console.log(`${this.name} flies in the sky`);
  }
}

// Function nháº­n base class - Polymorphism!
function makeAnimalSpeak(animal) {
  animal.speak(); // Gá»i Ä‘Ãºng method cá»§a derived class
  animal.move();
}

console.log("\n=== Method Overriding ===");

// Táº¡o array cÃ¡c animals khÃ¡c nhau
const animals = [new Dog("Buddy"), new Cat("Whiskers"), new Bird("Tweety")];

// CÃ¹ng method call, khÃ¡c behavior - POLYMORPHISM!
animals.forEach((animal) => {
  makeAnimalSpeak(animal);
  console.log("---");
});

// Output:
// Buddy: Woof! Woof!
// Buddy runs on 4 legs
// ---
// Whiskers: Meow! Meow!
// Whiskers walks gracefully
// ---
// Tweety: Tweet! Tweet!
// Tweety flies in the sky
// ---
```

```javascript
// VÃ­ dá»¥ thá»±c táº¿: Payment System vá»›i Polymorphism
class Payment {
  constructor(amount) {
    this.amount = amount;
  }

  process() {
    throw new Error("process() must be implemented");
  }

  refund() {
    throw new Error("refund() must be implemented");
  }
}

class CreditCardPayment extends Payment {
  constructor(amount, cardNumber) {
    super(amount);
    this.cardNumber = cardNumber;
  }

  process() {
    console.log(`Processing credit card payment: $${this.amount}`);
    console.log(`Card: ****${this.cardNumber.slice(-4)}`);
  }

  refund() {
    console.log(`Refunding $${this.amount} to credit card`);
  }
}

class PayPalPayment extends Payment {
  constructor(amount, email) {
    super(amount);
    this.email = email;
  }

  process() {
    console.log(`Processing PayPal payment: $${this.amount}`);
    console.log(`PayPal account: ${this.email}`);
  }

  refund() {
    console.log(`Refunding $${this.amount} to PayPal account`);
  }
}

class CryptoPayment extends Payment {
  constructor(amount, walletAddress) {
    super(amount);
    this.walletAddress = walletAddress;
  }

  process() {
    console.log(`Processing crypto payment: $${this.amount}`);
    console.log(`Wallet: ${this.walletAddress.slice(0, 10)}...`);
  }

  refund() {
    console.log(`Refunding $${this.amount} to crypto wallet`);
  }
}

// Payment Processor - sá»­ dá»¥ng Polymorphism
class PaymentProcessor {
  processPayment(payment) {
    // Nháº­n báº¥t ká»³ loáº¡i Payment nÃ o
    payment.process();
  }

  processMultiple(payments) {
    payments.forEach((payment) => {
      payment.process();
      console.log("---");
    });
  }
}

// Sá»­ dá»¥ng
const processor = new PaymentProcessor();

const payments = [
  new CreditCardPayment(100, "1234567890123456"),
  new PayPalPayment(50, "john@example.com"),
  new CryptoPayment(200, "0x1234567890abcdef"),
];

console.log("=== Payment Processing ===");
processor.processMultiple(payments);
```

---

### So sÃ¡nh OOP trong Java, C++, JavaScript

| TÃ­nh nÄƒng            | Java                             | C++                              | JavaScript                         |
| -------------------- | -------------------------------- | -------------------------------- | ---------------------------------- |
| **Class**            | `class` keyword                  | `class` keyword                  | `class` keyword (ES6+)             |
| **Encapsulation**    | `private`, `protected`, `public` | `private`, `protected`, `public` | `#` private fields (ES2022)        |
| **Abstraction**      | `abstract class`, `interface`    | Pure virtual functions           | Simulated vá»›i `throw Error`        |
| **Inheritance**      | `extends` (single)               | `:` (multiple)                   | `extends` (single)                 |
| **Polymorphism**     | Overloading + Overriding         | Overloading + Overriding         | Overriding (overloading simulated) |
| **Interface**        | `interface` keyword              | Abstract class                   | Duck typing                        |
| **Access Modifiers** | 4 levels                         | 3 levels                         | `#` private only                   |

---

## 4. VÃ¬ sao nÃªn há»c OOP

### Lá»£i Ã­ch cá»§a OOP

| Lá»£i Ã­ch                 | MÃ´ táº£                                    |
| ----------------------- | ---------------------------------------- |
| **Modularity**          | Code Ä‘Æ°á»£c chia thÃ nh cÃ¡c modules Ä‘á»™c láº­p |
| **Reusability**         | TÃ¡i sá»­ dá»¥ng code thÃ´ng qua inheritance   |
| **Maintainability**     | Dá»… báº£o trÃ¬ vÃ  sá»­a lá»—i                    |
| **Scalability**         | Dá»… má»Ÿ rá»™ng á»©ng dá»¥ng                      |
| **Security**            | Báº£o vá»‡ dá»¯ liá»‡u vá»›i encapsulation         |
| **Real-world modeling** | MÃ´ hÃ¬nh hÃ³a tháº¿ giá»›i thá»±c dá»… dÃ ng        |

### á»¨ng dá»¥ng thá»±c táº¿

```
âœ… Web Development (Java Spring, .NET, Django)
âœ… Mobile Development (Android, iOS)
âœ… Game Development (Unity, Unreal Engine)
âœ… Desktop Applications
âœ… Enterprise Software
âœ… Database Design
```

---

## 5. CÃ¡c háº¡n cháº¿ cá»§a láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng (OOP)

| Háº¡n cháº¿                  | Giáº£i thÃ­ch                            |
| ------------------------ | ------------------------------------- |
| **Complexity**           | CÃ³ thá»ƒ phá»©c táº¡p hÃ³a váº¥n Ä‘á» Ä‘Æ¡n giáº£n   |
| **Performance**          | Overhead do abstraction layers        |
| **Learning Curve**       | Cáº§n thá»i gian Ä‘á»ƒ hiá»ƒu vÃ  Ã¡p dá»¥ng Ä‘Ãºng |
| **Over-engineering**     | Dá»… thiáº¿t káº¿ quÃ¡ má»©c cáº§n thiáº¿t         |
| **Not suitable for all** | KhÃ´ng phÃ¹ há»£p cho má»i loáº¡i bÃ i toÃ¡n   |

### Khi nÃ o KHÃ”NG nÃªn dÃ¹ng OOP?

```
âŒ Scripts Ä‘Æ¡n giáº£n, automation
âŒ Data processing pipelines
âŒ Functional programming problems
âŒ Prototyping nhanh
```

---

## 6. Káº¿t luáº­n

### TÃ³m táº¯t 4 tÃ­nh cháº¥t OOP

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    4 PILLARS OF OOP                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ENCAPSULATION   â”‚ ÄÃ³ng gÃ³i data + methods, áº©n giáº¥u chi tiáº¿t â”‚
â”‚                 â”‚ â†’ Báº£o vá»‡ dá»¯ liá»‡u, kiá»ƒm soÃ¡t truy cáº­p      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ABSTRACTION     â”‚ áº¨n giáº¥u complexity, chá»‰ hiá»‡n cÃ¡i cáº§n thiáº¿tâ”‚
â”‚                 â”‚ â†’ ÄÆ¡n giáº£n hÃ³a, focus vÃ o "what"          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ INHERITANCE     â”‚ Káº¿ thá»«a attributes/methods tá»« parent      â”‚
â”‚                 â”‚ â†’ TÃ¡i sá»­ dá»¥ng code, táº¡o hierarchy         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POLYMORPHISM    â”‚ Má»™t interface, nhiá»u implementations      â”‚
â”‚                 â”‚ â†’ Linh hoáº¡t, dá»… má»Ÿ rá»™ng                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Máº¹o nhá»› nhanh

```
E - Encapsulation  â†’ "ÄÃ³ng há»™p" (private + getter/setter)
A - Abstraction    â†’ "Giáº¥u phá»©c táº¡p" (abstract class, interface)
I - Inheritance    â†’ "Con giá»‘ng cha" (extends)
P - Polymorphism   â†’ "Nhiá»u hÃ¬nh dáº¡ng" (overload, override)
```

### Best Practices

1. **SOLID Principles** - TuÃ¢n thá»§ nguyÃªn táº¯c SOLID
2. **Composition over Inheritance** - Æ¯u tiÃªn composition
3. **Program to Interface** - Láº­p trÃ¬nh theo interface
4. **Keep it Simple** - Äá»«ng over-engineer
5. **Single Responsibility** - Má»—i class má»™t nhiá»‡m vá»¥

---

## 7. SOLID Principles

SOLID lÃ  5 nguyÃªn táº¯c thiáº¿t káº¿ OOP giÃºp code dá»… maintain vÃ  má»Ÿ rá»™ng:

### S - Single Responsibility Principle (SRP)

> Má»—i class chá»‰ nÃªn cÃ³ **má»™t lÃ½ do Ä‘á»ƒ thay Ä‘á»•i**.

```java
// âŒ Vi pháº¡m SRP - Class lÃ m quÃ¡ nhiá»u viá»‡c
class User {
    void saveToDatabase() { }
    void sendEmail() { }
    void generateReport() { }
}

// âœ… TuÃ¢n thá»§ SRP - TÃ¡ch thÃ nh cÃ¡c class riÃªng
class User {
    String name;
    String email;
}

class UserRepository {
    void save(User user) { }
}

class EmailService {
    void sendEmail(User user, String message) { }
}

class ReportGenerator {
    void generateReport(User user) { }
}
```

### O - Open/Closed Principle (OCP)

> Class nÃªn **má»Ÿ Ä‘á»ƒ má»Ÿ rá»™ng**, nhÆ°ng **Ä‘Ã³ng Ä‘á»ƒ sá»­a Ä‘á»•i**.

```java
// âŒ Vi pháº¡m OCP - Pháº£i sá»­a code khi thÃªm shape má»›i
class AreaCalculator {
    double calculate(Object shape) {
        if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return Math.PI * c.radius * c.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.width * r.height;
        }
        // Pháº£i thÃªm else if khi cÃ³ shape má»›i
        return 0;
    }
}

// âœ… TuÃ¢n thá»§ OCP - Má»Ÿ rá»™ng báº±ng cÃ¡ch thÃªm class má»›i
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    double radius;
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Shape {
    double width, height;
    public double calculateArea() {
        return width * height;
    }
}

// ThÃªm shape má»›i khÃ´ng cáº§n sá»­a code cÅ©
class Triangle implements Shape {
    double base, height;
    public double calculateArea() {
        return 0.5 * base * height;
    }
}
```

### L - Liskov Substitution Principle (LSP)

> Objects cá»§a subclass pháº£i cÃ³ thá»ƒ **thay tháº¿** objects cá»§a superclass mÃ  khÃ´ng lÃ m há»ng chÆ°Æ¡ng trÃ¬nh.

```java
// âŒ Vi pháº¡m LSP
class Bird {
    void fly() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// âœ… TuÃ¢n thá»§ LSP
interface Bird {
    void eat();
}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    public void eat() { System.out.println("Eating seeds"); }
    public void fly() { System.out.println("Flying high"); }
}

class Penguin implements Bird {
    public void eat() { System.out.println("Eating fish"); }
    // KhÃ´ng cÃ³ fly() - há»£p lÃ½!
}
```

### I - Interface Segregation Principle (ISP)

> Client khÃ´ng nÃªn bá»‹ buá»™c phá»¥ thuá»™c vÃ o **interface mÃ  há» khÃ´ng sá»­ dá»¥ng**.

```java
// âŒ Vi pháº¡m ISP - Interface quÃ¡ lá»›n
interface Worker {
    void work();
    void eat();
    void sleep();
    void attendMeeting();
    void writeReport();
}

class Robot implements Worker {
    public void work() { /* OK */ }
    public void eat() { /* Robot khÃ´ng Äƒn?! */ }
    public void sleep() { /* Robot khÃ´ng ngá»§?! */ }
    // ...
}

// âœ… TuÃ¢n thá»§ ISP - TÃ¡ch thÃ nh cÃ¡c interface nhá»
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

class Human implements Workable, Eatable, Sleepable {
    public void work() { }
    public void eat() { }
    public void sleep() { }
}

class Robot implements Workable {
    public void work() { }
    // KhÃ´ng cáº§n implement eat(), sleep()
}
```

### D - Dependency Inversion Principle (DIP)

> - High-level modules khÃ´ng nÃªn phá»¥ thuá»™c vÃ o low-level modules
> - Cáº£ hai nÃªn phá»¥ thuá»™c vÃ o **abstractions**

```java
// âŒ Vi pháº¡m DIP - High-level phá»¥ thuá»™c low-level
class MySQLDatabase {
    void save(String data) { }
}

class UserService {
    private MySQLDatabase database = new MySQLDatabase(); // Tight coupling!

    void saveUser(String user) {
        database.save(user);
    }
}

// âœ… TuÃ¢n thá»§ DIP - Phá»¥ thuá»™c vÃ o abstraction
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) {
        System.out.println("Saving to MySQL");
    }
}

class MongoDatabase implements Database {
    public void save(String data) {
        System.out.println("Saving to MongoDB");
    }
}

class UserService {
    private Database database; // Phá»¥ thuá»™c vÃ o interface

    // Dependency Injection
    UserService(Database database) {
        this.database = database;
    }

    void saveUser(String user) {
        database.save(user);
    }
}

// Usage - Dá»… dÃ ng thay Ä‘á»•i database
UserService service1 = new UserService(new MySQLDatabase());
UserService service2 = new UserService(new MongoDatabase());
```

### TÃ³m táº¯t SOLID

| NguyÃªn táº¯c | Ã nghÄ©a                           | Keyword               |
| ---------- | --------------------------------- | --------------------- |
| **S**RP    | Má»™t class, má»™t nhiá»‡m vá»¥           | Single responsibility |
| **O**CP    | Má»Ÿ Ä‘á»ƒ má»Ÿ rá»™ng, Ä‘Ã³ng Ä‘á»ƒ sá»­a        | Open/Closed           |
| **L**SP    | Subclass thay tháº¿ Ä‘Æ°á»£c superclass | Substitution          |
| **I**SP    | Interface nhá», cá»¥ thá»ƒ             | Segregation           |
| **D**IP    | Phá»¥ thuá»™c vÃ o abstraction         | Dependency Inversion  |

---

## 8. Design Patterns phá»• biáº¿n trong OOP

### Creational Patterns

| Pattern       | Má»¥c Ä‘Ã­ch                            |
| ------------- | ----------------------------------- |
| **Singleton** | Äáº£m báº£o chá»‰ cÃ³ 1 instance           |
| **Factory**   | Táº¡o objects mÃ  khÃ´ng expose logic   |
| **Builder**   | XÃ¢y dá»±ng objects phá»©c táº¡p tá»«ng bÆ°á»›c |

### Structural Patterns

| Pattern       | Má»¥c Ä‘Ã­ch                        |
| ------------- | ------------------------------- |
| **Adapter**   | Chuyá»ƒn Ä‘á»•i interface            |
| **Decorator** | ThÃªm behavior Ä‘á»™ng              |
| **Facade**    | ÄÆ¡n giáº£n hÃ³a interface phá»©c táº¡p |

### Behavioral Patterns

| Pattern      | Má»¥c Ä‘Ã­ch                      |
| ------------ | ----------------------------- |
| **Observer** | Notify khi state thay Ä‘á»•i     |
| **Strategy** | Äá»•i algorithm runtime         |
| **Command**  | ÄÃ³ng gÃ³i request thÃ nh object |

---

## ğŸ“š TÃ i liá»‡u tham kháº£o

- [Head First Object-Oriented Analysis and Design](https://www.oreilly.com/library/view/head-first-object-oriented/0596008678/)
- [Clean Code - Robert C. Martin](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)
- [Design Patterns - Gang of Four](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/)
- [SOLID Principles](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)
