# OOP l√† g√¨? Chi ti·∫øt v·ªÅ l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng

## M·ª•c l·ª•c

1. [OOP l√† g√¨?](#1-oop-l√†-g√¨)
2. [C√°c th√†nh ph·∫ßn ch√≠nh trong OOP](#2-c√°c-th√†nh-ph·∫ßn-ch√≠nh-trong-oop)
3. [4 t√≠nh ch·∫•t c∆° b·∫£n trong OOP](#3-4-t√≠nh-ch·∫•t-c∆°-b·∫£n-trong-oop)
   - 3.1 [Encapsulation (T√≠nh ƒë√≥ng g√≥i)](#31-encapsulation-t√≠nh-ƒë√≥ng-g√≥i)
   - 3.2 [Abstraction (T√≠nh tr·ª´u t∆∞·ª£ng)](#32-abstraction-t√≠nh-tr·ª´u-t∆∞·ª£ng)
   - 3.3 [Inheritance (T√≠nh k·∫ø th·ª´a)](#33-inheritance-t√≠nh-k·∫ø-th·ª´a)
   - 3.4 [Polymorphism (T√≠nh ƒëa h√¨nh)](#34-polymorphism-t√≠nh-ƒëa-h√¨nh)
4. [V√¨ sao n√™n h·ªçc OOP](#4-v√¨-sao-n√™n-h·ªçc-oop)
5. [C√°c h·∫°n ch·∫ø c·ªßa OOP](#5-c√°c-h·∫°n-ch·∫ø-c·ªßa-l·∫≠p-tr√¨nh-h∆∞·ªõng-ƒë·ªëi-t∆∞·ª£ng-oop)
6. [K·∫øt lu·∫≠n](#6-k·∫øt-lu·∫≠n)

---

## Gi·ªõi thi·ªáu

Ch√∫ng ta ƒëang s·ª≠ d·ª•ng c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh ƒë·ªÉ gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ trong cu·ªôc s·ªëng h√†ng ng√†y. V√¨ th·∫ø s·∫Ω kh√¥ng l√Ω g√¨ ch√∫ng ta l·∫°i kh√¥ng th·ªÉ m√¥ h√¨nh c√°c v·∫•n ƒë·ªÅ n√†y sang c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng. ƒê√¢y ch√≠nh l√† n∆°i m√† l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (**Object-oriented programming**) ph√°t huy vai tr√≤ c·ªßa n√≥.

---

## 1. OOP l√† g√¨?

**OOP** l√† vi·∫øt t·∫Øt c·ªßa **Object-oriented programming** (l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng).

### ƒê·ªãnh nghƒ©a

OOP l√† vi·∫øt t·∫Øt c·ªßa Object-oriented programming (l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng). OOP l√† m·ªôt m√¥ h√¨nh l·∫≠p tr√¨nh d·ª±a tr√™n kh√°i ni·ªám v·ªÅ **Class** v√† **Object**. M√¥ h√¨nh n√†y t·∫≠p trung v√†o c√°c ƒë·ªëi t∆∞·ª£ng t∆∞∆°ng t√°c v·ªõi nhau
thay v√¨ t·∫≠p trung v√†o logic ƒë·ªÉ thao t√°c ch√∫ng.

### M·ª•c ti√™u ch√≠nh

- ‚úÖ Gi√∫p vi·ªác **qu·∫£n l√Ω m√£ ngu·ªìn** d·ªÖ d√†ng h∆°n
- ‚úÖ TƒÉng kh·∫£ nƒÉng **t√°i s·ª≠ d·ª•ng code**
- ‚úÖ **B·∫£o tr√¨** v√† **m·ªü r·ªông** code ƒë∆°n gi·∫£n h∆°n

### Th√†nh ph·∫ßn c·ªßa Object

Trong OOP, m·ªôt Object th∆∞·ªùng ch·ª©a 2 th√†nh ph·∫ßn:

1. **Data** (D·ªØ li·ªáu)

   - D∆∞·ªõi d·∫°ng c√°c **fields** (tr∆∞·ªùng)
   - C√≤n g·ªçi l√† **attributes** (thu·ªôc t√≠nh) ho·∫∑c **properties** (ƒë·∫∑c t√≠nh)

2. **Code** (M√£)
   - D∆∞·ªõi d·∫°ng c√°c **procedures** (th·ªß t·ª•c)
   - C√≤n g·ªçi l√† **methods** (ph∆∞∆°ng th·ª©c)

---

## 2. C√°c th√†nh ph·∫ßn ch√≠nh trong OOP

![C√°c th√†nh ph·∫ßn trong OOP - L·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng](../../09-RESOURCES/images/image18.png)

Trong OOP c√≥ 2 th√†nh ph·∫ßn ch√≠nh: **Class** v√† **Object**

### 2.1 Class (L·ªõp) trong OOP

**Class** l√† m·ªôt **template** (khu√¥n m·∫´u) hay **blueprint** (b·∫£n thi·∫øt k·∫ø) ƒë·ªÉ t·∫°o ra c√°c Object.

#### Class bao g·ªìm:

- **Attributes**: ƒê·ªãnh nghƒ©a c√°c th√¥ng tin, ƒë·∫∑c ƒëi·ªÉm, thu·ªôc t√≠nh c·ªßa Object
- **Methods**: ƒê·ªãnh nghƒ©a c√°c h√†nh vi, ph∆∞∆°ng th·ª©c, h√†nh ƒë·ªông c·ªßa Object

#### V√≠ d·ª• Class Person

```java
class Person {
    // Attributes (Thu·ªôc t√≠nh)
    String name;
    int age;
    String occupation;

    // Methods (Ph∆∞∆°ng th·ª©c)
    void eat() {
        System.out.println(name + " is eating");
    }

    void sleep() {
        System.out.println(name + " is sleeping");
    }

    void work() {
        System.out.println(name + " is working");
    }
}
```

### 2.2 Object (ƒê·ªëi t∆∞·ª£ng) trong OOP

**Object** l√† m·ªôt **instance** (th·ªÉ hi·ªán) c·ªßa Class - m·ªôt v√≠ d·ª• c·ª• th·ªÉ, hi·ªán th·ª±c c·ªßa m·ªôt Class.

#### V√≠ d·ª• Objects t·ª´ Class Person

![V√≠ d·ª• Objects](../../09-RESOURCES/images/image17.png)

```java
// T·∫°o Objects t·ª´ Class Person
Person person1 = new Person();
person1.name = "Nguy·ªÖn VƒÉn A";
person1.age = 25;
person1.occupation = "Developer";

Person person2 = new Person();
person2.name = "Tr·∫ßn Th·ªã B";
person2.age = 30;
person2.occupation = "Designer";

// S·ª≠ d·ª•ng methods
person1.eat();    // Output: Nguy·ªÖn VƒÉn A is eating
person2.work();   // Output: Tr·∫ßn Th·ªã B is working
```

**So s√°nh Class vs Object:**

```
Class Person = B·∫£n thi·∫øt k·∫ø con ng∆∞·ªùi
  ‚Üì
Object person1 = Nguy·ªÖn VƒÉn A (ng∆∞·ªùi c·ª• th·ªÉ)
Object person2 = Tr·∫ßn Th·ªã B (ng∆∞·ªùi c·ª• th·ªÉ)
```

---

## 3. 4 t√≠nh ch·∫•t c∆° b·∫£n trong OOP

![4 t√≠nh ch·∫•t OOP](../../09-RESOURCES/images/image19.png)

OOP c√≥ 4 t√≠nh ch·∫•t c∆° b·∫£n (4 tr·ª• c·ªôt):

1. **Encapsulation** (T√≠nh ƒë√≥ng g√≥i)
2. **Abstraction** (T√≠nh tr·ª´u t∆∞·ª£ng)
3. **Inheritance** (T√≠nh k·∫ø th·ª´a)
4. **Polymorphism** (T√≠nh ƒëa h√¨nh)

---

### 3.1 Encapsulation (T√≠nh ƒë√≥ng g√≥i)

#### ƒê·ªãnh nghƒ©a

**Encapsulation** l√† k·ªπ thu·∫≠t **gom nh√≥m** c√°c attributes v√† methods li√™n quan v√†o m·ªôt Object, ƒë·ªìng th·ªùi **·∫©n gi·∫•u** (hide) c√°c chi ti·∫øt b√™n trong.

#### M·ª•c ƒë√≠ch

- ‚úÖ **B·∫£o v·ªá d·ªØ li·ªáu** b√™n trong Object
- ‚úÖ **Ki·ªÉm so√°t** vi·ªác truy c·∫≠p v√† thay ƒë·ªïi d·ªØ li·ªáu
- ‚úÖ TƒÉng t√≠nh **b·∫£o m·∫≠t** v√† **an to√†n** cho ch∆∞∆°ng tr√¨nh

#### Access Modifiers

```java
public    // Truy c·∫≠p t·ª´ m·ªçi n∆°i
private   // Ch·ªâ truy c·∫≠p trong class
protected // Truy c·∫≠p trong class v√† class con
```

![Encapsulation](https://statics.cdn.200lab.io/2023/08/oop-encapsulation.jpg)

#### V√≠ d·ª•: Class Account

```java
class Account {
    // ‚ùå Private - Kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp t·ª´ b√™n ngo√†i
    private String name;
    private double balance;

    // ‚úÖ Public - C√≥ th·ªÉ truy c·∫≠p t·ª´ b√™n ngo√†i
    public Account(String name, double initialBalance) {
        this.name = name;
        this.balance = initialBalance;
    }

    // Getter - L·∫•y th√¥ng tin
    public String getName() {
        return this.name;
    }

    public double getBalance() {
        return this.balance;
    }

    // Methods - Thao t√°c v·ªõi d·ªØ li·ªáu
    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
            System.out.println("Deposited: " + amount);
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            System.out.println("Withdrawn: " + amount);
        } else {
            System.out.println("Insufficient balance!");
        }
    }
}
```

#### S·ª≠ d·ª•ng

```java
Account myAccount = new Account("John", 1000);

// ‚ùå KH√îNG th·ªÉ l√†m ƒëi·ªÅu n√†y (v√¨ balance l√† private)
// myAccount.balance = 999999;

// ‚úÖ Ph·∫£i s·ª≠ d·ª•ng methods public
myAccount.deposit(500);      // Deposited: 500
System.out.println(myAccount.getBalance()); // 1500

myAccount.withdraw(200);     // Withdrawn: 200
System.out.println(myAccount.getBalance()); // 1300
```

#### L·ª£i √≠ch c·ªßa Encapsulation

| L·ª£i √≠ch             | Gi·∫£i th√≠ch                                                |
| ------------------- | --------------------------------------------------------- |
| **Data Hiding**     | ·∫®n gi·∫•u d·ªØ li·ªáu nh·∫°y c·∫£m                                  |
| **Validation**      | Ki·ªÉm tra d·ªØ li·ªáu tr∆∞·ªõc khi thay ƒë·ªïi                       |
| **Flexibility**     | Thay ƒë·ªïi implementation m√† kh√¥ng ·∫£nh h∆∞·ªüng code b√™n ngo√†i |
| **Maintainability** | D·ªÖ b·∫£o tr√¨ v√† debug                                       |

#### V√≠ d·ª• th·ª±c t·∫ø

```java
class BankAccount {
    private String accountNumber;
    private String pin;
    private double balance;

    // Validate PIN tr∆∞·ªõc khi withdraw
    public boolean withdraw(String inputPin, double amount) {
        // B·∫£o m·∫≠t: Ki·ªÉm tra PIN
        if (!this.pin.equals(inputPin)) {
            System.out.println("Incorrect PIN!");
            return false;
        }

        // Validation: Ki·ªÉm tra s·ªë d∆∞
        if (amount > this.balance) {
            System.out.println("Insufficient balance!");
            return false;
        }

        // Th·ª±c hi·ªán giao d·ªãch
        this.balance -= amount;
        // Log transaction (c√≥ th·ªÉ th√™m logic ph·ª©c t·∫°p)
        logTransaction("WITHDRAW", amount);
        return true;
    }

    private void logTransaction(String type, double amount) {
        // Logic ghi log ph·ª©c t·∫°p ·ªü ƒë√¢y
        System.out.println(type + ": " + amount);
    }
}
```

**T·∫°i sao c·∫ßn Encapsulation?**

N·∫øu kh√¥ng c√≥ Encapsulation:

```java
// ‚ùå Kh√¥ng c√≥ Encapsulation
class BadAccount {
    public double balance; // Ai c≈©ng c√≥ th·ªÉ thay ƒë·ªïi
}

BadAccount acc = new BadAccount();
acc.balance = 1000;
// Ai ƒë√≥ c√≥ th·ªÉ l√†m ƒëi·ªÅu n√†y:
acc.balance = -999999; // S·ªë d∆∞ √¢m?! Kh√¥ng h·ª£p l√Ω!
```

V·ªõi Encapsulation:

```java
// ‚úÖ C√≥ Encapsulation
class GoodAccount {
    private double balance;

    public void setBalance(double balance) {
        if (balance >= 0) { // Validation
            this.balance = balance;
        } else {
            System.out.println("Balance cannot be negative!");
        }
    }
}
```

---

### 3.2 Abstraction (T√≠nh tr·ª´u t∆∞·ª£ng)

#### ƒê·ªãnh nghƒ©a

**Abstraction** l√† k·ªπ thu·∫≠t **ƒë∆°n gi·∫£n h√≥a** b·∫±ng c√°ch ch·ªâ hi·ªÉn th·ªã nh·ªØng th√¥ng tin **c·∫ßn thi·∫øt** v√† **·∫©n gi·∫•u** c√°c chi ti·∫øt ph·ª©c t·∫°p.

#### M·ª•c ƒë√≠ch

- ‚úÖ T·∫≠p trung v√†o **"c√°i g√¨"** thay v√¨ **"nh∆∞ th·∫ø n√†o"**
- ‚úÖ Gi·∫£m ƒë·ªô ph·ª©c t·∫°p
- ‚úÖ TƒÉng kh·∫£ nƒÉng t√°i s·ª≠ d·ª•ng

#### C√°ch th·ª±c hi·ªán Abstraction

1. **Abstract Class** - Class tr·ª´u t∆∞·ª£ng
2. **Interface** - Giao di·ªán

#### V√≠ d·ª• 1: Remote Control (ƒêi·ªÅu khi·ªÉn t·ª´ xa)

```java
// Abstract class
abstract class RemoteControl {
    // Abstract method - Kh√¥ng c√≥ implementation
    abstract void powerOn();
    abstract void powerOff();
    abstract void volumeUp();
    abstract void volumeDown();

    // Concrete method - C√≥ implementation
    public void showInfo() {
        System.out.println("This is a remote control");
    }
}

// TV Remote
class TVRemote extends RemoteControl {
    void powerOn() {
        System.out.println("TV is turning ON");
        // Logic ph·ª©c t·∫°p ƒë·ªÉ b·∫≠t TV (user kh√¥ng c·∫ßn bi·∫øt)
    }

    void powerOff() {
        System.out.println("TV is turning OFF");
    }

    void volumeUp() {
        System.out.println("TV volume UP");
    }

    void volumeDown() {
        System.out.println("TV volume DOWN");
    }
}

// AC Remote
class ACRemote extends RemoteControl {
    void powerOn() {
        System.out.println("AC is turning ON");
        // Logic kh√°c ƒë·ªÉ b·∫≠t ƒëi·ªÅu h√≤a
    }

    void powerOff() {
        System.out.println("AC is turning OFF");
    }

    void volumeUp() {
        System.out.println("AC temperature UP");
    }

    void volumeDown() {
        System.out.println("AC temperature DOWN");
    }
}
```

**S·ª≠ d·ª•ng:**

```java
RemoteControl tvRemote = new TVRemote();
tvRemote.powerOn();  // TV is turning ON
tvRemote.volumeUp(); // TV volume UP

RemoteControl acRemote = new ACRemote();
acRemote.powerOn();  // AC is turning ON
acRemote.volumeUp(); // AC temperature UP
```

**User ch·ªâ c·∫ßn bi·∫øt**:

- Nh·∫•n n√∫t ON ‚Üí Thi·∫øt b·ªã b·∫≠t
- Nh·∫•n n√∫t Volume UP ‚Üí TƒÉng √¢m l∆∞·ª£ng/nhi·ªát ƒë·ªô

**User kh√¥ng c·∫ßn bi·∫øt**:

- T√≠n hi·ªáu h·ªìng ngo·∫°i ho·∫°t ƒë·ªông th·∫ø n√†o
- M√£ h√≥a t√≠n hi·ªáu nh∆∞ th·∫ø n√†o
- Hardware x·ª≠ l√Ω t√≠n hi·ªáu ra sao

#### V√≠ d·ª• 2: UIElement

```java
// Abstract class cho UI Elements
abstract class UIElement {
    protected int x, y;
    protected int width, height;

    // Abstract method - M·ªói element render kh√°c nhau
    abstract void render();

    // Concrete method - Chung cho t·∫•t c·∫£ elements
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
    }
}

// Button element
class Button extends UIElement {
    private String label;

    void render() {
        System.out.println("Rendering Button: " + label);
        // Logic v·∫Ω button ph·ª©c t·∫°p
        // - V·∫Ω h√¨nh ch·ªØ nh·∫≠t
        // - Th√™m shadow
        // - V·∫Ω text
        // - Th√™m hover effect
    }
}

// Image element
class Image extends UIElement {
    private String imageUrl;

    void render() {
        System.out.println("Rendering Image: " + imageUrl);
        // Logic load v√† hi·ªÉn th·ªã ·∫£nh ph·ª©c t·∫°p
        // - T·∫£i ·∫£nh t·ª´ URL
        // - Resize ·∫£nh
        // - Apply filters
        // - Render l√™n canvas
    }
}

// TextInput element
class TextInput extends UIElement {
    private String placeholder;

    void render() {
        System.out.println("Rendering TextInput: " + placeholder);
        // Logic v·∫Ω input ph·ª©c t·∫°p
        // - V·∫Ω border
        // - V·∫Ω placeholder text
        // - Handle focus state
        // - Cursor animation
    }
}
```

**S·ª≠ d·ª•ng:**

```java
List<UIElement> elements = new ArrayList<>();
elements.add(new Button());
elements.add(new Image());
elements.add(new TextInput());

// Render t·∫•t c·∫£ elements
for (UIElement element : elements) {
    element.render(); // G·ªçi method chung, nh∆∞ng m·ªói element t·ª± x·ª≠ l√Ω
}
```

#### Interface - M·ªôt d·∫°ng Abstraction kh√°c

```java
interface Vehicle {
    void start();
    void stop();
    void accelerate();
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car: Turn key, engine starts");
    }

    public void stop() {
        System.out.println("Car: Press brake, engine stops");
    }

    public void accelerate() {
        System.out.println("Car: Press gas pedal");
    }
}

class Bicycle implements Vehicle {
    public void start() {
        System.out.println("Bicycle: Start pedaling");
    }

    public void stop() {
        System.out.println("Bicycle: Use hand brake");
    }

    public void accelerate() {
        System.out.println("Bicycle: Pedal faster");
    }
}
```

#### Abstraction vs Encapsulation

| Kh√≠a c·∫°nh          | Abstraction               | Encapsulation                      |
| ------------------ | ------------------------- | ---------------------------------- |
| **M·ª•c ƒë√≠ch**       | ·∫®n gi·∫•u **complexity**    | ·∫®n gi·∫•u **data**                   |
| **Focus**          | **What** it does          | **How** it does                    |
| **Implementation** | Abstract class, Interface | Access modifiers (private, public) |
| **Level**          | Design level              | Implementation level               |

#### V√≠ d·ª• th·ª±c t·∫ø: ATM Machine

```java
abstract class ATM {
    // User ch·ªâ bi·∫øt c√°c operations n√†y
    abstract void checkBalance();
    abstract void withdraw(double amount);
    abstract void deposit(double amount);

    // User KH√îNG c·∫ßn bi·∫øt:
    // - K·∫øt n·ªëi database nh∆∞ th·∫ø n√†o
    // - M√£ h√≥a d·ªØ li·ªáu ra sao
    // - X√°c th·ª±c th·∫ª nh∆∞ th·∫ø n√†o
    // - In bi√™n lai th·∫ø n√†o
}
```

---

### 3.3 Inheritance (T√≠nh k·∫ø th·ª´a)

#### ƒê·ªãnh nghƒ©a

**Inheritance** l√† c∆° ch·∫ø cho ph√©p m·ªôt class **k·∫ø th·ª´a** (inherit) c√°c attributes v√† methods t·ª´ class kh√°c.

#### Thu·∫≠t ng·ªØ

- **Parent Class** / **Base Class** / **Super Class**: Class cha
- **Child Class** / **Derived Class** / **Sub Class**: Class con

#### M·ª•c ƒë√≠ch

- ‚úÖ **T√°i s·ª≠ d·ª•ng code** (Code reusability)
- ‚úÖ Gi·∫£m **duplication** (tr√πng l·∫∑p)
- ‚úÖ T·∫°o **hierarchy** (ph√¢n c·∫•p) r√µ r√†ng

#### V√≠ d·ª• 1: Animal Hierarchy

```java
// Parent class
class Animal {
    String name;
    int age;

    void eat() {
        System.out.println(name + " is eating");
    }

    void sleep() {
        System.out.println(name + " is sleeping");
    }

    void makeSound() {
        System.out.println(name + " makes a sound");
    }
}

// Child class 1
class Dog extends Animal {
    String breed;

    // Override method t·ª´ parent
    @Override
    void makeSound() {
        System.out.println(name + " barks: Woof! Woof!");
    }

    // Method ri√™ng c·ªßa Dog
    void fetch() {
        System.out.println(name + " is fetching the ball");
    }
}

// Child class 2
class Cat extends Animal {
    boolean isIndoor;

    @Override
    void makeSound() {
        System.out.println(name + " meows: Meow! Meow!");
    }

    // Method ri√™ng c·ªßa Cat
    void scratch() {
        System.out.println(name + " is scratching");
    }
}

// Child class 3
class Bird extends Animal {
    boolean canFly;

    @Override
    void makeSound() {
        System.out.println(name + " chirps: Tweet! Tweet!");
    }

    void fly() {
        if (canFly) {
            System.out.println(name + " is flying");
        }
    }
}
```

**S·ª≠ d·ª•ng:**

```java
Dog dog = new Dog();
dog.name = "Buddy";
dog.age = 3;
dog.breed = "Golden Retriever";

// Methods t·ª´ Animal (k·∫ø th·ª´a)
dog.eat();       // Buddy is eating
dog.sleep();     // Buddy is sleeping

// Method override
dog.makeSound(); // Buddy barks: Woof! Woof!

// Method ri√™ng c·ªßa Dog
dog.fetch();     // Buddy is fetching the ball

Cat cat = new Cat();
cat.name = "Whiskers";
cat.age = 2;
cat.makeSound(); // Whiskers meows: Meow! Meow!
cat.scratch();   // Whiskers is scratching
```

#### Visualization

```
        Animal (Parent)
        ‚îú‚îÄ name
        ‚îú‚îÄ age
        ‚îú‚îÄ eat()
        ‚îú‚îÄ sleep()
        ‚îî‚îÄ makeSound()
           ‚Üì (k·∫ø th·ª´a)
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ      ‚îÇ      ‚îÇ
   Dog    Cat   Bird
(+ breed) (+ isIndoor) (+ canFly)
(+ fetch()) (+ scratch()) (+ fly())
```

#### Lo·∫°i Inheritance

##### 1. Single Inheritance (ƒê∆°n k·∫ø th·ª´a)

M·ªôt class ch·ªâ k·∫ø th·ª´a t·ª´ **m·ªôt** parent class duy nh·∫•t.

```java
class Vehicle {
    void start() { }
}

class Car extends Vehicle {
    // Car ch·ªâ k·∫ø th·ª´a t·ª´ Vehicle
}
```

##### 2. Multiple Inheritance (ƒêa k·∫ø th·ª´a)

M·ªôt class k·∫ø th·ª´a t·ª´ **nhi·ªÅu** parent classes.

> ‚ö†Ô∏è **L∆∞u √Ω**: Java **KH√îNG** h·ªó tr·ª£ multiple inheritance v·ªõi classes (ƒë·ªÉ tr√°nh Diamond Problem)

```java
// ‚ùå KH√îNG th·ªÉ l√†m ƒëi·ªÅu n√†y trong Java
class FlyingCar extends Car, Aircraft {
    // ERROR: Multiple inheritance not supported
}
```

**Gi·∫£i ph√°p**: S·ª≠ d·ª•ng **Interface**

```java
interface Flyable {
    void fly();
}

interface Drivable {
    void drive();
}

// ‚úÖ C√≥ th·ªÉ implement nhi·ªÅu interfaces
class FlyingCar implements Flyable, Drivable {
    public void fly() {
        System.out.println("Flying in the sky");
    }

    public void drive() {
        System.out.println("Driving on the road");
    }
}
```

#### "Is-a" Relationship

"Is-a" gi√∫p x√°c ƒë·ªãnh khi n√†o n√™n d√πng k·∫ø th·ª´a.

```
Dog IS-A Animal          ‚úÖ ƒê√∫ng ‚Üí Dog extends Animal
Car IS-A Vehicle         ‚úÖ ƒê√∫ng ‚Üí Car extends Vehicle
Button IS-A UIElement    ‚úÖ ƒê√∫ng ‚Üí Button extends UIElement

Dog IS-A Car             ‚ùå Sai ‚Üí Kh√¥ng n√™n k·∫ø th·ª´a
```

**V√≠ d·ª• th·ª±c t·∫ø:**

```java
// Shape hierarchy
class Shape {
    String color;
    void draw() { }
}

class Circle extends Shape {
    // Circle IS-A Shape ‚úÖ
    double radius;
}

class Rectangle extends Shape {
    // Rectangle IS-A Shape ‚úÖ
    double width;
    double height;
}

class Triangle extends Shape {
    // Triangle IS-A Shape ‚úÖ
    double base;
    double height;
}
```

#### "Has-a" Relationship (Composition)

"Has-a" l√† **thay th·∫ø** cho k·∫ø th·ª´a, s·ª≠ d·ª•ng **composition** (ph·ªëi h·ª£p).

```java
// ‚ùå Kh√¥ng n√™n: Car extends Engine (Car IS-A Engine? Sai!)

// ‚úÖ N√™n: Car HAS-A Engine
class Engine {
    int horsepower;
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    Engine engine; // Car HAS-A Engine

    Car() {
        this.engine = new Engine();
    }

    void start() {
        engine.start();
        System.out.println("Car started");
    }
}
```

**Th√™m v√≠ d·ª• Has-a:**

```java
class Customer {
    String name;
    String email;
}

class Product {
    String name;
    double price;
}

class Order {
    Customer customer;    // Order HAS-A Customer
    List<Product> products; // Order HAS-A List of Products
    double totalAmount;
}
```

#### Khi n√†o d√πng Inheritance vs Composition?

```
Inheritance (Is-a):
‚úÖ C√≥ m·ªëi quan h·ªá r√µ r√†ng "is-a"
‚úÖ Child class l√† m·ªôt d·∫°ng ƒë·∫∑c bi·ªát c·ªßa Parent class
‚úÖ C·∫ßn override methods t·ª´ parent

Composition (Has-a):
‚úÖ C·∫ßn t√≠nh linh ho·∫°t cao
‚úÖ Mu·ªën tr√°nh tight coupling
‚úÖ C·∫ßn k·∫øt h·ª£p nhi·ªÅu functionalities
```

---

### 3.4 Polymorphism (T√≠nh ƒëa h√¨nh)

#### ƒê·ªãnh nghƒ©a

**Polymorphism** = "Poly" (nhi·ªÅu) + "Morph" (h√¨nh d·∫°ng)

Polymorphism cho ph√©p m·ªôt Object c√≥ th·ªÉ c√≥ **nhi·ªÅu h√¨nh d·∫°ng** v√† **h√†nh vi** kh√°c nhau.

#### Ph√¢n lo·∫°i

![Polymorphism](https://statics.cdn.200lab.io/2023/08/oop-polymorphism.jpg)

1. **Static Polymorphism** (Compile-time)
   - Method Overloading
2. **Dynamic Polymorphism** (Runtime)
   - Method Overriding

---

#### Static Polymorphism (Method Overloading)

**ƒê·ªãnh nghƒ©a**: Nhi·ªÅu methods **c√πng t√™n** nh∆∞ng **kh√°c tham s·ªë** trong c√πng m·ªôt class.

**ƒêi·ªÅu ki·ªán ƒë·ªÉ Overloading:**

- C√πng t√™n method
- Kh√°c s·ªë l∆∞·ª£ng tham s·ªë, HO·∫∂C
- Kh√°c ki·ªÉu d·ªØ li·ªáu tham s·ªë

```java
class Calculator {
    // Method 1: C·ªông 2 s·ªë int
    int add(int a, int b) {
        return a + b;
    }

    // Method 2: C·ªông 3 s·ªë int (kh√°c s·ªë l∆∞·ª£ng tham s·ªë)
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method 3: C·ªông 2 s·ªë double (kh√°c ki·ªÉu tham s·ªë)
    double add(double a, double b) {
        return a + b;
    }

    // Method 4: C·ªông array
    int add(int[] numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
}
```

**S·ª≠ d·ª•ng:**

```java
Calculator calc = new Calculator();

System.out.println(calc.add(5, 3));           // 8 (Method 1)
System.out.println(calc.add(5, 3, 2));        // 10 (Method 2)
System.out.println(calc.add(5.5, 3.2));       // 8.7 (Method 3)
System.out.println(calc.add(new int[]{1,2,3})); // 6 (Method 4)
```

**V√≠ d·ª• th·ª±c t·∫ø: Print method**

```java
class Printer {
    void print(String text) {
        System.out.println("Text: " + text);
    }

    void print(int number) {
        System.out.println("Number: " + number);
    }

    void print(String text, int copies) {
        for (int i = 0; i < copies; i++) {
            System.out.println("Text: " + text);
        }
    }

    void print(String[] texts) {
        for (String text : texts) {
            System.out.println("Text: " + text);
        }
    }
}
```

**L·ª£i √≠ch c·ªßa Method Overloading:**

- ‚úÖ Code d·ªÖ ƒë·ªçc, d·ªÖ nh·ªõ (c√πng t√™n method)
- ‚úÖ TƒÉng t√≠nh linh ho·∫°t
- ‚úÖ Gi·∫£m s·ª± ph·ª©c t·∫°p

---

#### Dynamic Polymorphism (Method Overriding)

**ƒê·ªãnh nghƒ©a**: Child class **ƒë·ªãnh nghƒ©a l·∫°i** (ghi ƒë√®) method t·ª´ Parent class v·ªõi **c√πng signature** (t√™n, tham s·ªë, return type).

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }

    void move() {
        System.out.println("Animal moves");
    }
}

class Dog extends Animal {
    // Override method makeSound()
    @Override
    void makeSound() {
        System.out.println("Dog barks: Woof! Woof!");
    }

    @Override
    void move() {
        System.out.println("Dog runs on 4 legs");
    }
}

class Bird extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bird chirps: Tweet! Tweet!");
    }

    @Override
    void move() {
        System.out.println("Bird flies in the sky");
    }
}

class Fish extends Animal {
    @Override
    void makeSound() {
        System.out.println("Fish makes bubbles: Blub! Blub!");
    }

    @Override
    void move() {
        System.out.println("Fish swims in water");
    }
}
```

**S·ª≠ d·ª•ng - Runtime Polymorphism:**

````java
// Parent reference, Child object
Animal animal1 = new Dog();
Animal animal2 = new Bird();
Animal animal3 = new Fish();

// C√πng method call, nh∆∞ng behavior kh√°c nhau
animal1.makeSound(); // Dog barks: Woof! Woof!
animal2.makeSound(); // Bird chirps: Tweet! Tweet!
animal3.makeSound(); // Fish makes bubbles: Blub! Blub!

animal1.move();      // Dog runs on 4 legs
animal2.move();      // Bird flies in the sky
animal3.move();      // Fish swims in water

**
V√≠ d·ª• th·ª±c t·∫ø: Payment System**

```java
abstract class Payment {
    protected double amount;

    abstract void processPayment();
    abstract void refund();
}

class CreditCardPayment extends Payment {
    private String cardNumber;

    @Override
    void processPayment() {
        System.out.println("Processing credit card payment: $" + amount);
        // Logic x·ª≠ l√Ω th·∫ª t√≠n d·ª•ng
        // - Validate card
        // - Connect to payment gateway
        // - Charge card
    }

    @Override
    void refund() {
        System.out.println("Refunding to credit card: $" + amount);
    }
}

class PayPalPayment extends Payment {
    private String email;

    @Override
    void processPayment() {
        System.out.println("Processing PayPal payment: $" + amount);
        // Logic x·ª≠ l√Ω PayPal
        // - Redirect to PayPal
        // - Authenticate user
        // - Complete transaction
    }

    @Override
    void refund() {
        System.out.println("Refunding to PayPal account: $" + amount);
    }
}

class CryptoPayment extends Payment {
    private String walletAddress;

    @Override
    void processPayment() {
        System.out.println("Processing crypto payment: $" + amount);
        // Logic x·ª≠ l√Ω crypto
        // - Generate wallet address
        // - Wait for blockchain confirmation
    }

    @Override
    void refund() {
        System.out.println("Refunding to crypto wallet: $" + amount);
    }
}
````

**S·ª≠ d·ª•ng Polymorphism trong th·ª±c t·∫ø:**

```java
class PaymentProcessor {
    // Nh·∫≠n b·∫•t k·ª≥ lo·∫°i Payment n√†o
    void process(Payment payment) {
        payment.processPayment();
    }

    void processMultiple(List<Payment> payments) {
        for (Payment payment : payments) {
            payment.processPayment(); // Polymorphism!
        }
    }
}

// Usage
PaymentProcessor processor = new PaymentProcessor();

Payment creditCard = new CreditCardPayment();
Payment paypal = new PayPalPayment();
Payment crypto = new CryptoPayment();

processor.process(creditCard); // Processing credit card payment
processor.process(paypal);     // Processing PayPal payment
processor.process(crypto);     // Processing crypto payment
```

#### So s√°nh Overloading vs Overriding

| Ti√™u ch√≠             | Overloading           | Overriding                  |
| -------------------- | --------------------- | --------------------------- |
| **Lo·∫°i**             | Static (Compile-time) | Dynamic (Runtime)           |
| **V·ªã tr√≠**           | C√πng class            | Parent-Child classes        |
| **Method signature** | Kh√°c tham s·ªë          | Gi·ªëng ho√†n to√†n             |
| **Return type**      | C√≥ th·ªÉ kh√°c           | Ph·∫£i gi·ªëng (ho·∫∑c covariant) |
| **Access modifier**  | C√≥ th·ªÉ kh√°c           | Kh√¥ng ƒë∆∞·ª£c restrictive h∆°n  |
| **Annotation**       | Kh√¥ng c·∫ßn             | `@Override` (recommended)   |

#### L·ª£i √≠ch c·ªßa Polymorphism

| L·ª£i √≠ch              | Gi·∫£i th√≠ch                                        |
| -------------------- | ------------------------------------------------- |
| **Flexibility**      | Code linh ho·∫°t, d·ªÖ m·ªü r·ªông                        |
| **Maintainability**  | D·ªÖ b·∫£o tr√¨, th√™m lo·∫°i m·ªõi kh√¥ng ·∫£nh h∆∞·ªüng code c≈© |
| **Loose Coupling**   | Gi·∫£m s·ª± ph·ª• thu·ªôc gi·ªØa c√°c components             |
| **Code Reusability** | T√°i s·ª≠ d·ª•ng code hi·ªáu qu·∫£                         |

---

## 4. V√¨ sao n√™n h·ªçc OOP

### L·ª£i √≠ch c·ªßa OOP

| L·ª£i √≠ch                 | M√¥ t·∫£                                    |
| ----------------------- | ---------------------------------------- |
| **Modularity**          | Code ƒë∆∞·ª£c chia th√†nh c√°c modules ƒë·ªôc l·∫≠p |
| **Reusability**         | T√°i s·ª≠ d·ª•ng code th√¥ng qua inheritance   |
| **Maintainability**     | D·ªÖ b·∫£o tr√¨ v√† s·ª≠a l·ªói                    |
| **Scalability**         | D·ªÖ m·ªü r·ªông ·ª©ng d·ª•ng                      |
| **Security**            | B·∫£o v·ªá d·ªØ li·ªáu v·ªõi encapsulation         |
| **Real-world modeling** | M√¥ h√¨nh h√≥a th·∫ø gi·ªõi th·ª±c d·ªÖ d√†ng        |

### ·ª®ng d·ª•ng th·ª±c t·∫ø

```
‚úÖ Web Development (Java Spring, .NET, Django)
‚úÖ Mobile Development (Android, iOS)
‚úÖ Game Development (Unity, Unreal Engine)
‚úÖ Desktop Applications
‚úÖ Enterprise Software
‚úÖ Database Design
```

---

## 5. C√°c h·∫°n ch·∫ø c·ªßa l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (OOP)

| H·∫°n ch·∫ø                  | Gi·∫£i th√≠ch                            |
| ------------------------ | ------------------------------------- |
| **Complexity**           | C√≥ th·ªÉ ph·ª©c t·∫°p h√≥a v·∫•n ƒë·ªÅ ƒë∆°n gi·∫£n   |
| **Performance**          | Overhead do abstraction layers        |
| **Learning Curve**       | C·∫ßn th·ªùi gian ƒë·ªÉ hi·ªÉu v√† √°p d·ª•ng ƒë√∫ng |
| **Over-engineering**     | D·ªÖ thi·∫øt k·∫ø qu√° m·ª©c c·∫ßn thi·∫øt         |
| **Not suitable for all** | Kh√¥ng ph√π h·ª£p cho m·ªçi lo·∫°i b√†i to√°n   |

### Khi n√†o KH√îNG n√™n d√πng OOP?

```
‚ùå Scripts ƒë∆°n gi·∫£n, automation
‚ùå Data processing pipelines
‚ùå Functional programming problems
‚ùå Prototyping nhanh
```

---

## 6. K·∫øt lu·∫≠n

### T√≥m t·∫Øt 4 t√≠nh ch·∫•t OOP

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    4 PILLARS OF OOP                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ENCAPSULATION   ‚îÇ ƒê√≥ng g√≥i data + methods, ·∫©n gi·∫•u chi ti·∫øt ‚îÇ
‚îÇ                 ‚îÇ ‚Üí B·∫£o v·ªá d·ªØ li·ªáu, ki·ªÉm so√°t truy c·∫≠p      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ABSTRACTION     ‚îÇ ·∫®n gi·∫•u complexity, ch·ªâ hi·ªán c√°i c·∫ßn thi·∫øt‚îÇ
‚îÇ                 ‚îÇ ‚Üí ƒê∆°n gi·∫£n h√≥a, focus v√†o "what"          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INHERITANCE     ‚îÇ K·∫ø th·ª´a attributes/methods t·ª´ parent      ‚îÇ
‚îÇ                 ‚îÇ ‚Üí T√°i s·ª≠ d·ª•ng code, t·∫°o hierarchy         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ POLYMORPHISM    ‚îÇ M·ªôt interface, nhi·ªÅu implementations      ‚îÇ
‚îÇ                 ‚îÇ ‚Üí Linh ho·∫°t, d·ªÖ m·ªü r·ªông                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### M·∫πo nh·ªõ nhanh

```
E - Encapsulation  ‚Üí "ƒê√≥ng h·ªôp" (private + getter/setter)
A - Abstraction    ‚Üí "Gi·∫•u ph·ª©c t·∫°p" (abstract class, interface)
I - Inheritance    ‚Üí "Con gi·ªëng cha" (extends)
P - Polymorphism   ‚Üí "Nhi·ªÅu h√¨nh d·∫°ng" (overload, override)
```

### Best Practices

1. **SOLID Principles** - Tu√¢n th·ªß nguy√™n t·∫Øc SOLID
2. **Composition over Inheritance** - ∆Øu ti√™n composition
3. **Program to Interface** - L·∫≠p tr√¨nh theo interface
4. **Keep it Simple** - ƒê·ª´ng over-engineer
5. **Single Responsibility** - M·ªói class m·ªôt nhi·ªám v·ª•

---

## 7. SOLID Principles

SOLID l√† 5 nguy√™n t·∫Øc thi·∫øt k·∫ø OOP gi√∫p code d·ªÖ maintain v√† m·ªü r·ªông:

### S - Single Responsibility Principle (SRP)

> M·ªói class ch·ªâ n√™n c√≥ **m·ªôt l√Ω do ƒë·ªÉ thay ƒë·ªïi**.

```java
// ‚ùå Vi ph·∫°m SRP - Class l√†m qu√° nhi·ªÅu vi·ªác
class User {
    void saveToDatabase() { }
    void sendEmail() { }
    void generateReport() { }
}

// ‚úÖ Tu√¢n th·ªß SRP - T√°ch th√†nh c√°c class ri√™ng
class User {
    String name;
    String email;
}

class UserRepository {
    void save(User user) { }
}

class EmailService {
    void sendEmail(User user, String message) { }
}

class ReportGenerator {
    void generateReport(User user) { }
}
```

### O - Open/Closed Principle (OCP)

> Class n√™n **m·ªü ƒë·ªÉ m·ªü r·ªông**, nh∆∞ng **ƒë√≥ng ƒë·ªÉ s·ª≠a ƒë·ªïi**.

```java
// ‚ùå Vi ph·∫°m OCP - Ph·∫£i s·ª≠a code khi th√™m shape m·ªõi
class AreaCalculator {
    double calculate(Object shape) {
        if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return Math.PI * c.radius * c.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.width * r.height;
        }
        // Ph·∫£i th√™m else if khi c√≥ shape m·ªõi
        return 0;
    }
}

// ‚úÖ Tu√¢n th·ªß OCP - M·ªü r·ªông b·∫±ng c√°ch th√™m class m·ªõi
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    double radius;
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Shape {
    double width, height;
    public double calculateArea() {
        return width * height;
    }
}

// Th√™m shape m·ªõi kh√¥ng c·∫ßn s·ª≠a code c≈©
class Triangle implements Shape {
    double base, height;
    public double calculateArea() {
        return 0.5 * base * height;
    }
}
```

### L - Liskov Substitution Principle (LSP)

> Objects c·ªßa subclass ph·∫£i c√≥ th·ªÉ **thay th·∫ø** objects c·ªßa superclass m√† kh√¥ng l√†m h·ªèng ch∆∞∆°ng tr√¨nh.

```java
// ‚ùå Vi ph·∫°m LSP
class Bird {
    void fly() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// ‚úÖ Tu√¢n th·ªß LSP
interface Bird {
    void eat();
}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    public void eat() { System.out.println("Eating seeds"); }
    public void fly() { System.out.println("Flying high"); }
}

class Penguin implements Bird {
    public void eat() { System.out.println("Eating fish"); }
    // Kh√¥ng c√≥ fly() - h·ª£p l√Ω!
}
```

### I - Interface Segregation Principle (ISP)

> Client kh√¥ng n√™n b·ªã bu·ªôc ph·ª• thu·ªôc v√†o **interface m√† h·ªç kh√¥ng s·ª≠ d·ª•ng**.

```java
// ‚ùå Vi ph·∫°m ISP - Interface qu√° l·ªõn
interface Worker {
    void work();
    void eat();
    void sleep();
    void attendMeeting();
    void writeReport();
}

class Robot implements Worker {
    public void work() { /* OK */ }
    public void eat() { /* Robot kh√¥ng ƒÉn?! */ }
    public void sleep() { /* Robot kh√¥ng ng·ªß?! */ }
    // ...
}

// ‚úÖ Tu√¢n th·ªß ISP - T√°ch th√†nh c√°c interface nh·ªè
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

class Human implements Workable, Eatable, Sleepable {
    public void work() { }
    public void eat() { }
    public void sleep() { }
}

class Robot implements Workable {
    public void work() { }
    // Kh√¥ng c·∫ßn implement eat(), sleep()
}
```

### D - Dependency Inversion Principle (DIP)

> - High-level modules kh√¥ng n√™n ph·ª• thu·ªôc v√†o low-level modules
> - C·∫£ hai n√™n ph·ª• thu·ªôc v√†o **abstractions**

```java
// ‚ùå Vi ph·∫°m DIP - High-level ph·ª• thu·ªôc low-level
class MySQLDatabase {
    void save(String data) { }
}

class UserService {
    private MySQLDatabase database = new MySQLDatabase(); // Tight coupling!

    void saveUser(String user) {
        database.save(user);
    }
}

// ‚úÖ Tu√¢n th·ªß DIP - Ph·ª• thu·ªôc v√†o abstraction
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) {
        System.out.println("Saving to MySQL");
    }
}

class MongoDatabase implements Database {
    public void save(String data) {
        System.out.println("Saving to MongoDB");
    }
}

class UserService {
    private Database database; // Ph·ª• thu·ªôc v√†o interface

    // Dependency Injection
    UserService(Database database) {
        this.database = database;
    }

    void saveUser(String user) {
        database.save(user);
    }
}

// Usage - D·ªÖ d√†ng thay ƒë·ªïi database
UserService service1 = new UserService(new MySQLDatabase());
UserService service2 = new UserService(new MongoDatabase());
```

### T√≥m t·∫Øt SOLID

| Nguy√™n t·∫Øc | √ù nghƒ©a                           | Keyword               |
| ---------- | --------------------------------- | --------------------- |
| **S**RP    | M·ªôt class, m·ªôt nhi·ªám v·ª•           | Single responsibility |
| **O**CP    | M·ªü ƒë·ªÉ m·ªü r·ªông, ƒë√≥ng ƒë·ªÉ s·ª≠a        | Open/Closed           |
| **L**SP    | Subclass thay th·∫ø ƒë∆∞·ª£c superclass | Substitution          |
| **I**SP    | Interface nh·ªè, c·ª• th·ªÉ             | Segregation           |
| **D**IP    | Ph·ª• thu·ªôc v√†o abstraction         | Dependency Inversion  |

---

## 8. Design Patterns ph·ªï bi·∫øn trong OOP

### Creational Patterns

| Pattern       | M·ª•c ƒë√≠ch                            |
| ------------- | ----------------------------------- |
| **Singleton** | ƒê·∫£m b·∫£o ch·ªâ c√≥ 1 instance           |
| **Factory**   | T·∫°o objects m√† kh√¥ng expose logic   |
| **Builder**   | X√¢y d·ª±ng objects ph·ª©c t·∫°p t·ª´ng b∆∞·ªõc |

### Structural Patterns

| Pattern       | M·ª•c ƒë√≠ch                        |
| ------------- | ------------------------------- |
| **Adapter**   | Chuy·ªÉn ƒë·ªïi interface            |
| **Decorator** | Th√™m behavior ƒë·ªông              |
| **Facade**    | ƒê∆°n gi·∫£n h√≥a interface ph·ª©c t·∫°p |

### Behavioral Patterns

| Pattern      | M·ª•c ƒë√≠ch                      |
| ------------ | ----------------------------- |
| **Observer** | Notify khi state thay ƒë·ªïi     |
| **Strategy** | ƒê·ªïi algorithm runtime         |
| **Command**  | ƒê√≥ng g√≥i request th√†nh object |

---

## üìö T√†i li·ªáu tham kh·∫£o

- [Head First Object-Oriented Analysis and Design](https://www.oreilly.com/library/view/head-first-object-oriented/0596008678/)
- [Clean Code - Robert C. Martin](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)
- [Design Patterns - Gang of Four](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/)
- [SOLID Principles](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)
